// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: geo/geo.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018-2019 AirMap, Inc.  All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Coordinate2D models a WGS84 latitude and longitude.
struct Geo_Coordinate2D {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The latitude component.
  var latitude: Units_Degrees {
    get {return _storage._latitude ?? Units_Degrees()}
    set {_uniqueStorage()._latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return _storage._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {_uniqueStorage()._latitude = nil}

  /// The longitude component.
  var longitude: Units_Degrees {
    get {return _storage._longitude ?? Units_Degrees()}
    set {_uniqueStorage()._longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return _storage._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {_uniqueStorage()._longitude = nil}

  /// The error in the measurement.
  var error: Geo_Coordinate2D.Error {
    get {return _storage._error ?? Geo_Coordinate2D.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in a coordinate measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error estimate on the latitude measurement.
    var latitude: Units_Degrees {
      get {return _storage._latitude ?? Units_Degrees()}
      set {_uniqueStorage()._latitude = newValue}
    }
    /// Returns true if `latitude` has been explicitly set.
    var hasLatitude: Bool {return _storage._latitude != nil}
    /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
    mutating func clearLatitude() {_uniqueStorage()._latitude = nil}

    /// The error estimate on the longitude measurement.
    var longitude: Units_Degrees {
      get {return _storage._longitude ?? Units_Degrees()}
      set {_uniqueStorage()._longitude = newValue}
    }
    /// Returns true if `longitude` has been explicitly set.
    var hasLongitude: Bool {return _storage._longitude != nil}
    /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
    mutating func clearLongitude() {_uniqueStorage()._longitude = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Position models a postion in time
struct Geo_Position4D {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time applicability of the position
  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  /// The position at a given time
  var position: Measurements_Position.Absolute {
    get {return _storage._position ?? Measurements_Position.Absolute()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return _storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {_uniqueStorage()._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BoundingBox models a geographic bounds
struct Geo_BoundingBox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The southwest-most extent of the bounds
  var southwest: Geo_Coordinate2D {
    get {return _storage._southwest ?? Geo_Coordinate2D()}
    set {_uniqueStorage()._southwest = newValue}
  }
  /// Returns true if `southwest` has been explicitly set.
  var hasSouthwest: Bool {return _storage._southwest != nil}
  /// Clears the value of `southwest`. Subsequent reads from it will return its default value.
  mutating func clearSouthwest() {_uniqueStorage()._southwest = nil}

  /// The northeast-most extent of the bounds
  var northeast: Geo_Coordinate2D {
    get {return _storage._northeast ?? Geo_Coordinate2D()}
    set {_uniqueStorage()._northeast = newValue}
  }
  /// Returns true if `northeast` has been explicitly set.
  var hasNortheast: Bool {return _storage._northeast != nil}
  /// Clears the value of `northeast`. Subsequent reads from it will return its default value.
  mutating func clearNortheast() {_uniqueStorage()._northeast = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LinearRing models an array of point coordinates where the first and last point as equal.
struct Geo_LinearRing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coordinates: [Geo_Coordinate2D] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Polygon models an array of LinearRings where the first ring is the exterior ring and subsequent rings
/// represent the interior rings/cutouts.
struct Geo_Polygon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rings: [Geo_LinearRing] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "geo"

extension Geo_Coordinate2D: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Coordinate2D"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _latitude: Units_Degrees? = nil
    var _longitude: Units_Degrees? = nil
    var _error: Geo_Coordinate2D.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _latitude = source._latitude
      _longitude = source._longitude
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._latitude)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._longitude)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._latitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._longitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Geo_Coordinate2D, rhs: Geo_Coordinate2D) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Geo_Coordinate2D.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Geo_Coordinate2D.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  fileprivate class _StorageClass {
    var _latitude: Units_Degrees? = nil
    var _longitude: Units_Degrees? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _latitude = source._latitude
      _longitude = source._longitude
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._latitude)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._longitude)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._latitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._longitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Geo_Coordinate2D.Error, rhs: Geo_Coordinate2D.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Geo_Position4D: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position4D"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "position"),
  ]

  fileprivate class _StorageClass {
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _position: Measurements_Position.Absolute? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamp = source._timestamp
      _position = source._position
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._position)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Geo_Position4D, rhs: Geo_Position4D) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._position != rhs_storage._position {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Geo_BoundingBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoundingBox"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "southwest"),
    2: .same(proto: "northeast"),
  ]

  fileprivate class _StorageClass {
    var _southwest: Geo_Coordinate2D? = nil
    var _northeast: Geo_Coordinate2D? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _southwest = source._southwest
      _northeast = source._northeast
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._southwest)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._northeast)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._southwest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._northeast {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Geo_BoundingBox, rhs: Geo_BoundingBox) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._southwest != rhs_storage._southwest {return false}
        if _storage._northeast != rhs_storage._northeast {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Geo_LinearRing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinearRing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coordinates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.coordinates)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.coordinates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coordinates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Geo_LinearRing, rhs: Geo_LinearRing) -> Bool {
    if lhs.coordinates != rhs.coordinates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Geo_Polygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Polygon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.rings)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Geo_Polygon, rhs: Geo_Polygon) -> Bool {
    if lhs.rings != rhs.rings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
