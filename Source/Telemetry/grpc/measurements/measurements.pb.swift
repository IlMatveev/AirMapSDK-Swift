// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: measurements/measurements.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018-2019 AirMap, Inc.  All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Position models a spatial location.
struct Measurements_Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details is a descriminated union of all Position types
  var details: OneOf_Details? {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  var absolute: Measurements_Position.Absolute {
    get {
      if case .absolute(let v)? = _storage._details {return v}
      return Measurements_Position.Absolute()
    }
    set {_uniqueStorage()._details = .absolute(newValue)}
  }

  var relative: Measurements_Position.Relative {
    get {
      if case .relative(let v)? = _storage._details {return v}
      return Measurements_Position.Relative()
    }
    set {_uniqueStorage()._details = .relative(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Details is a descriminated union of all Position types
  enum OneOf_Details: Equatable {
    case absolute(Measurements_Position.Absolute)
    case relative(Measurements_Position.Relative)

  #if !swift(>=4.1)
    static func ==(lhs: Measurements_Position.OneOf_Details, rhs: Measurements_Position.OneOf_Details) -> Bool {
      switch (lhs, rhs) {
      case (.absolute(let l), .absolute(let r)): return l == r
      case (.relative(let l), .relative(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Absolute models an absolute position.
  struct Absolute {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The latitude and longitude component of the position.
    var coordinate: Measurements_Coordinate2D {
      get {return _storage._coordinate ?? Measurements_Coordinate2D()}
      set {_uniqueStorage()._coordinate = newValue}
    }
    /// Returns true if `coordinate` has been explicitly set.
    var hasCoordinate: Bool {return _storage._coordinate != nil}
    /// Clears the value of `coordinate`. Subsequent reads from it will return its default value.
    mutating func clearCoordinate() {_uniqueStorage()._coordinate = nil}

    /// The altitude component of the position.
    var altitude: Measurements_Altitude {
      get {return _storage._altitude ?? Measurements_Altitude()}
      set {_uniqueStorage()._altitude = newValue}
    }
    /// Returns true if `altitude` has been explicitly set.
    var hasAltitude: Bool {return _storage._altitude != nil}
    /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
    mutating func clearAltitude() {_uniqueStorage()._altitude = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Relative models a position relative to an absolute position.
  struct Relative {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The reference position from which the relative measurement is anchored.
    var reference: Measurements_Position.Absolute {
      get {return _storage._reference ?? Measurements_Position.Absolute()}
      set {_uniqueStorage()._reference = newValue}
    }
    /// Returns true if `reference` has been explicitly set.
    var hasReference: Bool {return _storage._reference != nil}
    /// Clears the value of `reference`. Subsequent reads from it will return its default value.
    mutating func clearReference() {_uniqueStorage()._reference = nil}

    /// The distance from the reference position.
    var distance: Units_Meters {
      get {return _storage._distance ?? Units_Meters()}
      set {_uniqueStorage()._distance = newValue}
    }
    /// Returns true if `distance` has been explicitly set.
    var hasDistance: Bool {return _storage._distance != nil}
    /// Clears the value of `distance`. Subsequent reads from it will return its default value.
    mutating func clearDistance() {_uniqueStorage()._distance = nil}

    /// The bearing from the reference position relative to true north.
    var azimuth: Units_Degrees {
      get {return _storage._azimuth ?? Units_Degrees()}
      set {_uniqueStorage()._azimuth = newValue}
    }
    /// Returns true if `azimuth` has been explicitly set.
    var hasAzimuth: Bool {return _storage._azimuth != nil}
    /// Clears the value of `azimuth`. Subsequent reads from it will return its default value.
    mutating func clearAzimuth() {_uniqueStorage()._azimuth = nil}

    /// The error in the measurement.
    var error: Measurements_Position.Relative.Error {
      get {return _storage._error ?? Measurements_Position.Relative.Error()}
      set {_uniqueStorage()._error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    var hasError: Bool {return _storage._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    mutating func clearError() {_uniqueStorage()._error = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Error {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The error estimate on the distance measurement.
      var distance: Units_Meters {
        get {return _storage._distance ?? Units_Meters()}
        set {_uniqueStorage()._distance = newValue}
      }
      /// Returns true if `distance` has been explicitly set.
      var hasDistance: Bool {return _storage._distance != nil}
      /// Clears the value of `distance`. Subsequent reads from it will return its default value.
      mutating func clearDistance() {_uniqueStorage()._distance = nil}

      /// The error estimate on the azimuth measurement.
      var azimuth: Units_Degrees {
        get {return _storage._azimuth ?? Units_Degrees()}
        set {_uniqueStorage()._azimuth = newValue}
      }
      /// Returns true if `azimuth` has been explicitly set.
      var hasAzimuth: Bool {return _storage._azimuth != nil}
      /// Clears the value of `azimuth`. Subsequent reads from it will return its default value.
      mutating func clearAzimuth() {_uniqueStorage()._azimuth = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Coordinate2D models a WGS84 latitude and longitude.
struct Measurements_Coordinate2D {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The latitude component.
  var latitude: Units_Degrees {
    get {return _storage._latitude ?? Units_Degrees()}
    set {_uniqueStorage()._latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return _storage._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {_uniqueStorage()._latitude = nil}

  /// The longitude component.
  var longitude: Units_Degrees {
    get {return _storage._longitude ?? Units_Degrees()}
    set {_uniqueStorage()._longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return _storage._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {_uniqueStorage()._longitude = nil}

  /// The error in the measurement.
  var error: Measurements_Coordinate2D.Error {
    get {return _storage._error ?? Measurements_Coordinate2D.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in a coordinate measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error estimate on the latitude measurement.
    var latitude: Units_Degrees {
      get {return _storage._latitude ?? Units_Degrees()}
      set {_uniqueStorage()._latitude = newValue}
    }
    /// Returns true if `latitude` has been explicitly set.
    var hasLatitude: Bool {return _storage._latitude != nil}
    /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
    mutating func clearLatitude() {_uniqueStorage()._latitude = nil}

    /// The error estimate on the longitude measurement.
    var longitude: Units_Degrees {
      get {return _storage._longitude ?? Units_Degrees()}
      set {_uniqueStorage()._longitude = newValue}
    }
    /// Returns true if `longitude` has been explicitly set.
    var hasLongitude: Bool {return _storage._longitude != nil}
    /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
    mutating func clearLongitude() {_uniqueStorage()._longitude = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Altitude models a height measurement from a given datum/reference.
struct Measurements_Altitude {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The altitude as measured from the reference.
  var height: Units_Meters {
    get {return _storage._height ?? Units_Meters()}
    set {_uniqueStorage()._height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return _storage._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {_uniqueStorage()._height = nil}

  /// The reference from which the altitude was measured.
  var reference: Measurements_Altitude.Reference {
    get {return _storage._reference}
    set {_uniqueStorage()._reference = newValue}
  }

  /// The error in the measurement.
  var error: Measurements_Altitude.Error {
    get {return _storage._error ?? Measurements_Altitude.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Reference enumerates all known reference/datum systems for altitude measurements.
  enum Reference: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// An unknown reference.
    case unknown // = 0

    /// Height above the WGS84 reference ellipsoid.
    case ellipsoid // = 1

    /// Height above the hypothetical gravitational surface.
    case geoid // = 2

    /// (DO NOT USE) Height above the physical surface beneath the measurement.
    case surface // = 3

    /// (DO NOT USE) Height above an external measurement or estimate.
    case external // = 4

    /// Altitude using standard atmospheric pressure. 1013.25 hPa, 29.92 in Hg. Flight Level (FL).
    case standardBaro // = 5

    /// Altitude relative to local sea level adjusted for local barometric pressure. AMSL.
    case localBaro // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ellipsoid
      case 2: self = .geoid
      case 3: self = .surface
      case 4: self = .external
      case 5: self = .standardBaro
      case 6: self = .localBaro
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ellipsoid: return 1
      case .geoid: return 2
      case .surface: return 3
      case .external: return 4
      case .standardBaro: return 5
      case .localBaro: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Error models the inherent error in the altitude measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The altitude error estimate.
    var height: Units_Meters {
      get {return _storage._height ?? Units_Meters()}
      set {_uniqueStorage()._height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    var hasHeight: Bool {return _storage._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    mutating func clearHeight() {_uniqueStorage()._height = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Measurements_Altitude.Reference: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Measurements_Altitude.Reference] = [
    .unknown,
    .ellipsoid,
    .geoid,
    .surface,
    .external,
    .standardBaro,
    .localBaro,
  ]
}

#endif  // swift(>=4.2)

/// Velocity models a velocity measurement.
struct Measurements_Velocity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var details: OneOf_Details? {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  var polar: Measurements_Velocity.Polar {
    get {
      if case .polar(let v)? = _storage._details {return v}
      return Measurements_Velocity.Polar()
    }
    set {_uniqueStorage()._details = .polar(newValue)}
  }

  var cartesian: Measurements_Velocity.Cartesian {
    get {
      if case .cartesian(let v)? = _storage._details {return v}
      return Measurements_Velocity.Cartesian()
    }
    set {_uniqueStorage()._details = .cartesian(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Details: Equatable {
    case polar(Measurements_Velocity.Polar)
    case cartesian(Measurements_Velocity.Cartesian)

  #if !swift(>=4.1)
    static func ==(lhs: Measurements_Velocity.OneOf_Details, rhs: Measurements_Velocity.OneOf_Details) -> Bool {
      switch (lhs, rhs) {
      case (.polar(let l), .polar(let r)): return l == r
      case (.cartesian(let l), .cartesian(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Polar Velocity models a velocity relative to a heading.
  struct Polar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The heading relative to true north.
    var heading: Units_Degrees {
      get {return _storage._heading ?? Units_Degrees()}
      set {_uniqueStorage()._heading = newValue}
    }
    /// Returns true if `heading` has been explicitly set.
    var hasHeading: Bool {return _storage._heading != nil}
    /// Clears the value of `heading`. Subsequent reads from it will return its default value.
    mutating func clearHeading() {_uniqueStorage()._heading = nil}

    /// The horizontal speed component relative to the ground.
    var groundSpeed: Units_MetersPerSecond {
      get {return _storage._groundSpeed ?? Units_MetersPerSecond()}
      set {_uniqueStorage()._groundSpeed = newValue}
    }
    /// Returns true if `groundSpeed` has been explicitly set.
    var hasGroundSpeed: Bool {return _storage._groundSpeed != nil}
    /// Clears the value of `groundSpeed`. Subsequent reads from it will return its default value.
    mutating func clearGroundSpeed() {_uniqueStorage()._groundSpeed = nil}

    /// The vertical speed component.
    var climbRate: Units_MetersPerSecond {
      get {return _storage._climbRate ?? Units_MetersPerSecond()}
      set {_uniqueStorage()._climbRate = newValue}
    }
    /// Returns true if `climbRate` has been explicitly set.
    var hasClimbRate: Bool {return _storage._climbRate != nil}
    /// Clears the value of `climbRate`. Subsequent reads from it will return its default value.
    mutating func clearClimbRate() {_uniqueStorage()._climbRate = nil}

    /// The error of the measurement.
    var error: Measurements_Velocity.Polar.Error {
      get {return _storage._error ?? Measurements_Velocity.Polar.Error()}
      set {_uniqueStorage()._error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    var hasError: Bool {return _storage._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    mutating func clearError() {_uniqueStorage()._error = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Error models the inherent error in the polar velocity measurement.
    struct Error {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The error in the heading.
      var heading: Units_Degrees {
        get {return _storage._heading ?? Units_Degrees()}
        set {_uniqueStorage()._heading = newValue}
      }
      /// Returns true if `heading` has been explicitly set.
      var hasHeading: Bool {return _storage._heading != nil}
      /// Clears the value of `heading`. Subsequent reads from it will return its default value.
      mutating func clearHeading() {_uniqueStorage()._heading = nil}

      /// The error in the ground speed.
      var groundSpeed: Units_MetersPerSecond {
        get {return _storage._groundSpeed ?? Units_MetersPerSecond()}
        set {_uniqueStorage()._groundSpeed = newValue}
      }
      /// Returns true if `groundSpeed` has been explicitly set.
      var hasGroundSpeed: Bool {return _storage._groundSpeed != nil}
      /// Clears the value of `groundSpeed`. Subsequent reads from it will return its default value.
      mutating func clearGroundSpeed() {_uniqueStorage()._groundSpeed = nil}

      /// The error in the vertical speed.
      var climbRate: Units_MetersPerSecond {
        get {return _storage._climbRate ?? Units_MetersPerSecond()}
        set {_uniqueStorage()._climbRate = newValue}
      }
      /// Returns true if `climbRate` has been explicitly set.
      var hasClimbRate: Bool {return _storage._climbRate != nil}
      /// Clears the value of `climbRate`. Subsequent reads from it will return its default value.
      mutating func clearClimbRate() {_uniqueStorage()._climbRate = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Cartesian Velocity models a velocity as XYZ vectors in the NED (north-east-down) coordinate space.
  /// *To convert from ENU (east-north-up), set (X, Y, Z) to (N, E, negative-U) values respectively.
  struct Cartesian {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The velocity along the X axis.
    var x: Units_MetersPerSecond {
      get {return _storage._x ?? Units_MetersPerSecond()}
      set {_uniqueStorage()._x = newValue}
    }
    /// Returns true if `x` has been explicitly set.
    var hasX: Bool {return _storage._x != nil}
    /// Clears the value of `x`. Subsequent reads from it will return its default value.
    mutating func clearX() {_uniqueStorage()._x = nil}

    /// The velocity along the Y axis.
    var y: Units_MetersPerSecond {
      get {return _storage._y ?? Units_MetersPerSecond()}
      set {_uniqueStorage()._y = newValue}
    }
    /// Returns true if `y` has been explicitly set.
    var hasY: Bool {return _storage._y != nil}
    /// Clears the value of `y`. Subsequent reads from it will return its default value.
    mutating func clearY() {_uniqueStorage()._y = nil}

    /// The velocity along the Z axis.
    var z: Units_MetersPerSecond {
      get {return _storage._z ?? Units_MetersPerSecond()}
      set {_uniqueStorage()._z = newValue}
    }
    /// Returns true if `z` has been explicitly set.
    var hasZ: Bool {return _storage._z != nil}
    /// Clears the value of `z`. Subsequent reads from it will return its default value.
    mutating func clearZ() {_uniqueStorage()._z = nil}

    /// The error of the measurement.
    var error: Measurements_Velocity.Cartesian.Error {
      get {return _storage._error ?? Measurements_Velocity.Cartesian.Error()}
      set {_uniqueStorage()._error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    var hasError: Bool {return _storage._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    mutating func clearError() {_uniqueStorage()._error = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Error models the inherent error in the cartesian velocity measurement.
    struct Error {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The error along the X axis.
      var x: Units_MetersPerSecond {
        get {return _storage._x ?? Units_MetersPerSecond()}
        set {_uniqueStorage()._x = newValue}
      }
      /// Returns true if `x` has been explicitly set.
      var hasX: Bool {return _storage._x != nil}
      /// Clears the value of `x`. Subsequent reads from it will return its default value.
      mutating func clearX() {_uniqueStorage()._x = nil}

      /// The error along the Y axis.
      var y: Units_MetersPerSecond {
        get {return _storage._y ?? Units_MetersPerSecond()}
        set {_uniqueStorage()._y = newValue}
      }
      /// Returns true if `y` has been explicitly set.
      var hasY: Bool {return _storage._y != nil}
      /// Clears the value of `y`. Subsequent reads from it will return its default value.
      mutating func clearY() {_uniqueStorage()._y = nil}

      /// The error along the Z axis.
      var z: Units_MetersPerSecond {
        get {return _storage._z ?? Units_MetersPerSecond()}
        set {_uniqueStorage()._z = newValue}
      }
      /// Returns true if `z` has been explicitly set.
      var hasZ: Bool {return _storage._z != nil}
      /// Clears the value of `z`. Subsequent reads from it will return its default value.
      mutating func clearZ() {_uniqueStorage()._z = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Orientation models an attitude or positional orientation measurement.
struct Measurements_Orientation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The angular rotation of the vehicle along its vertical axis relative to True North.
  var yaw: Units_Degrees {
    get {return _storage._yaw ?? Units_Degrees()}
    set {_uniqueStorage()._yaw = newValue}
  }
  /// Returns true if `yaw` has been explicitly set.
  var hasYaw: Bool {return _storage._yaw != nil}
  /// Clears the value of `yaw`. Subsequent reads from it will return its default value.
  mutating func clearYaw() {_uniqueStorage()._yaw = nil}

  /// The angular rotation of the vehicle along its lateral axis.
  var pitch: Units_Degrees {
    get {return _storage._pitch ?? Units_Degrees()}
    set {_uniqueStorage()._pitch = newValue}
  }
  /// Returns true if `pitch` has been explicitly set.
  var hasPitch: Bool {return _storage._pitch != nil}
  /// Clears the value of `pitch`. Subsequent reads from it will return its default value.
  mutating func clearPitch() {_uniqueStorage()._pitch = nil}

  /// The angular rotation of the vehicle along its longitudinal axis.
  var roll: Units_Degrees {
    get {return _storage._roll ?? Units_Degrees()}
    set {_uniqueStorage()._roll = newValue}
  }
  /// Returns true if `roll` has been explicitly set.
  var hasRoll: Bool {return _storage._roll != nil}
  /// Clears the value of `roll`. Subsequent reads from it will return its default value.
  mutating func clearRoll() {_uniqueStorage()._roll = nil}

  /// The error of the measurement.
  var error: Measurements_Orientation.Error {
    get {return _storage._error ?? Measurements_Orientation.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in the orientation measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error in angular rotation of the vehicle along its vertical axis relative to True North.
    var yaw: Units_Degrees {
      get {return _storage._yaw ?? Units_Degrees()}
      set {_uniqueStorage()._yaw = newValue}
    }
    /// Returns true if `yaw` has been explicitly set.
    var hasYaw: Bool {return _storage._yaw != nil}
    /// Clears the value of `yaw`. Subsequent reads from it will return its default value.
    mutating func clearYaw() {_uniqueStorage()._yaw = nil}

    /// The error in angular rotation of the vehicle along its lateral axis.
    var pitch: Units_Degrees {
      get {return _storage._pitch ?? Units_Degrees()}
      set {_uniqueStorage()._pitch = newValue}
    }
    /// Returns true if `pitch` has been explicitly set.
    var hasPitch: Bool {return _storage._pitch != nil}
    /// Clears the value of `pitch`. Subsequent reads from it will return its default value.
    mutating func clearPitch() {_uniqueStorage()._pitch = nil}

    /// The error in angular rotation of the vehicle along its longitudinal axis.
    var roll: Units_Degrees {
      get {return _storage._roll ?? Units_Degrees()}
      set {_uniqueStorage()._roll = newValue}
    }
    /// Returns true if `roll` has been explicitly set.
    var hasRoll: Bool {return _storage._roll != nil}
    /// Clears the value of `roll`. Subsequent reads from it will return its default value.
    mutating func clearRoll() {_uniqueStorage()._roll = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Acceleration models an acceleration measurement.
struct Measurements_Acceleration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The acceleration along the X axis.
  var x: Units_MetersPerSecondSquared {
    get {return _storage._x ?? Units_MetersPerSecondSquared()}
    set {_uniqueStorage()._x = newValue}
  }
  /// Returns true if `x` has been explicitly set.
  var hasX: Bool {return _storage._x != nil}
  /// Clears the value of `x`. Subsequent reads from it will return its default value.
  mutating func clearX() {_uniqueStorage()._x = nil}

  /// The acceleration along the Y axis.
  var y: Units_MetersPerSecondSquared {
    get {return _storage._y ?? Units_MetersPerSecondSquared()}
    set {_uniqueStorage()._y = newValue}
  }
  /// Returns true if `y` has been explicitly set.
  var hasY: Bool {return _storage._y != nil}
  /// Clears the value of `y`. Subsequent reads from it will return its default value.
  mutating func clearY() {_uniqueStorage()._y = nil}

  /// The acceleration along the Z axis.
  var z: Units_MetersPerSecondSquared {
    get {return _storage._z ?? Units_MetersPerSecondSquared()}
    set {_uniqueStorage()._z = newValue}
  }
  /// Returns true if `z` has been explicitly set.
  var hasZ: Bool {return _storage._z != nil}
  /// Clears the value of `z`. Subsequent reads from it will return its default value.
  mutating func clearZ() {_uniqueStorage()._z = nil}

  var error: Measurements_Acceleration.Error {
    get {return _storage._error ?? Measurements_Acceleration.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in an acceleration measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error along the X axis.
    var x: Units_MetersPerSecond {
      get {return _storage._x ?? Units_MetersPerSecond()}
      set {_uniqueStorage()._x = newValue}
    }
    /// Returns true if `x` has been explicitly set.
    var hasX: Bool {return _storage._x != nil}
    /// Clears the value of `x`. Subsequent reads from it will return its default value.
    mutating func clearX() {_uniqueStorage()._x = nil}

    /// The error along the Y axis.
    var y: Units_MetersPerSecond {
      get {return _storage._y ?? Units_MetersPerSecond()}
      set {_uniqueStorage()._y = newValue}
    }
    /// Returns true if `y` has been explicitly set.
    var hasY: Bool {return _storage._y != nil}
    /// Clears the value of `y`. Subsequent reads from it will return its default value.
    mutating func clearY() {_uniqueStorage()._y = nil}

    /// The error along the Z axis.
    var z: Units_MetersPerSecond {
      get {return _storage._z ?? Units_MetersPerSecond()}
      set {_uniqueStorage()._z = newValue}
    }
    /// Returns true if `z` has been explicitly set.
    var hasZ: Bool {return _storage._z != nil}
    /// Clears the value of `z`. Subsequent reads from it will return its default value.
    mutating func clearZ() {_uniqueStorage()._z = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "measurements"

extension Measurements_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "absolute"),
    2: .same(proto: "relative"),
  ]

  fileprivate class _StorageClass {
    var _details: Measurements_Position.OneOf_Details?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _details = source._details
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Measurements_Position.Absolute?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .absolute(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .absolute(v)}
        case 2:
          var v: Measurements_Position.Relative?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .relative(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .relative(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._details {
      case .absolute(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .relative(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Position, rhs: Measurements_Position) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._details != rhs_storage._details {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Position.Absolute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Position.protoMessageName + ".Absolute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coordinate"),
    2: .same(proto: "altitude"),
  ]

  fileprivate class _StorageClass {
    var _coordinate: Measurements_Coordinate2D? = nil
    var _altitude: Measurements_Altitude? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _coordinate = source._coordinate
      _altitude = source._altitude
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._coordinate)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._altitude)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._coordinate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._altitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Position.Absolute, rhs: Measurements_Position.Absolute) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coordinate != rhs_storage._coordinate {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Position.Relative: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Position.protoMessageName + ".Relative"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reference"),
    2: .same(proto: "distance"),
    3: .same(proto: "azimuth"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _reference: Measurements_Position.Absolute? = nil
    var _distance: Units_Meters? = nil
    var _azimuth: Units_Degrees? = nil
    var _error: Measurements_Position.Relative.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _reference = source._reference
      _distance = source._distance
      _azimuth = source._azimuth
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._reference)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._distance)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._azimuth)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._reference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._distance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._azimuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Position.Relative, rhs: Measurements_Position.Relative) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._reference != rhs_storage._reference {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._azimuth != rhs_storage._azimuth {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Position.Relative.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Position.Relative.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "distance"),
    2: .same(proto: "azimuth"),
  ]

  fileprivate class _StorageClass {
    var _distance: Units_Meters? = nil
    var _azimuth: Units_Degrees? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _distance = source._distance
      _azimuth = source._azimuth
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._distance)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._azimuth)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._distance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._azimuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Position.Relative.Error, rhs: Measurements_Position.Relative.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._azimuth != rhs_storage._azimuth {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Coordinate2D: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Coordinate2D"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _latitude: Units_Degrees? = nil
    var _longitude: Units_Degrees? = nil
    var _error: Measurements_Coordinate2D.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _latitude = source._latitude
      _longitude = source._longitude
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._latitude)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._longitude)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._latitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._longitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Coordinate2D, rhs: Measurements_Coordinate2D) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Coordinate2D.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Coordinate2D.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  fileprivate class _StorageClass {
    var _latitude: Units_Degrees? = nil
    var _longitude: Units_Degrees? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _latitude = source._latitude
      _longitude = source._longitude
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._latitude)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._longitude)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._latitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._longitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Coordinate2D.Error, rhs: Measurements_Coordinate2D.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Altitude: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Altitude"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "reference"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _height: Units_Meters? = nil
    var _reference: Measurements_Altitude.Reference = .unknown
    var _error: Measurements_Altitude.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _reference = source._reference
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._height)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._reference)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._height {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._reference != .unknown {
        try visitor.visitSingularEnumField(value: _storage._reference, fieldNumber: 2)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Altitude, rhs: Measurements_Altitude) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._reference != rhs_storage._reference {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Altitude.Reference: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REFERENCE_UNKNOWN"),
    1: .same(proto: "REFERENCE_ELLIPSOID"),
    2: .same(proto: "REFERENCE_GEOID"),
    3: .same(proto: "REFERENCE_SURFACE"),
    4: .same(proto: "REFERENCE_EXTERNAL"),
    5: .same(proto: "REFERENCE_STANDARD_BARO"),
    6: .same(proto: "REFERENCE_LOCAL_BARO"),
  ]
}

extension Measurements_Altitude.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Altitude.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  fileprivate class _StorageClass {
    var _height: Units_Meters? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._height)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._height {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Altitude.Error, rhs: Measurements_Altitude.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Velocity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Velocity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "polar"),
    2: .same(proto: "cartesian"),
  ]

  fileprivate class _StorageClass {
    var _details: Measurements_Velocity.OneOf_Details?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _details = source._details
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Measurements_Velocity.Polar?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .polar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .polar(v)}
        case 2:
          var v: Measurements_Velocity.Cartesian?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .cartesian(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .cartesian(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._details {
      case .polar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .cartesian(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Velocity, rhs: Measurements_Velocity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._details != rhs_storage._details {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Velocity.Polar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Velocity.protoMessageName + ".Polar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "heading"),
    2: .same(proto: "groundSpeed"),
    3: .same(proto: "climbRate"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _heading: Units_Degrees? = nil
    var _groundSpeed: Units_MetersPerSecond? = nil
    var _climbRate: Units_MetersPerSecond? = nil
    var _error: Measurements_Velocity.Polar.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _heading = source._heading
      _groundSpeed = source._groundSpeed
      _climbRate = source._climbRate
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._heading)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._groundSpeed)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._climbRate)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._heading {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._groundSpeed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._climbRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Velocity.Polar, rhs: Measurements_Velocity.Polar) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._heading != rhs_storage._heading {return false}
        if _storage._groundSpeed != rhs_storage._groundSpeed {return false}
        if _storage._climbRate != rhs_storage._climbRate {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Velocity.Polar.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Velocity.Polar.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "heading"),
    2: .same(proto: "groundSpeed"),
    3: .same(proto: "climbRate"),
  ]

  fileprivate class _StorageClass {
    var _heading: Units_Degrees? = nil
    var _groundSpeed: Units_MetersPerSecond? = nil
    var _climbRate: Units_MetersPerSecond? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _heading = source._heading
      _groundSpeed = source._groundSpeed
      _climbRate = source._climbRate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._heading)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._groundSpeed)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._climbRate)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._heading {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._groundSpeed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._climbRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Velocity.Polar.Error, rhs: Measurements_Velocity.Polar.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._heading != rhs_storage._heading {return false}
        if _storage._groundSpeed != rhs_storage._groundSpeed {return false}
        if _storage._climbRate != rhs_storage._climbRate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Velocity.Cartesian: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Velocity.protoMessageName + ".Cartesian"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _x: Units_MetersPerSecond? = nil
    var _y: Units_MetersPerSecond? = nil
    var _z: Units_MetersPerSecond? = nil
    var _error: Measurements_Velocity.Cartesian.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _x = source._x
      _y = source._y
      _z = source._z
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._x)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._y)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._z)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._x {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._y {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._z {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Velocity.Cartesian, rhs: Measurements_Velocity.Cartesian) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._x != rhs_storage._x {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._z != rhs_storage._z {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Velocity.Cartesian.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Velocity.Cartesian.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  fileprivate class _StorageClass {
    var _x: Units_MetersPerSecond? = nil
    var _y: Units_MetersPerSecond? = nil
    var _z: Units_MetersPerSecond? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _x = source._x
      _y = source._y
      _z = source._z
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._x)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._y)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._z)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._x {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._y {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._z {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Velocity.Cartesian.Error, rhs: Measurements_Velocity.Cartesian.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._x != rhs_storage._x {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._z != rhs_storage._z {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Orientation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Orientation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "yaw"),
    2: .same(proto: "pitch"),
    3: .same(proto: "roll"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _yaw: Units_Degrees? = nil
    var _pitch: Units_Degrees? = nil
    var _roll: Units_Degrees? = nil
    var _error: Measurements_Orientation.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _yaw = source._yaw
      _pitch = source._pitch
      _roll = source._roll
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._yaw)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pitch)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._roll)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._yaw {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pitch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._roll {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Orientation, rhs: Measurements_Orientation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._yaw != rhs_storage._yaw {return false}
        if _storage._pitch != rhs_storage._pitch {return false}
        if _storage._roll != rhs_storage._roll {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Orientation.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Orientation.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "yaw"),
    2: .same(proto: "pitch"),
    3: .same(proto: "roll"),
  ]

  fileprivate class _StorageClass {
    var _yaw: Units_Degrees? = nil
    var _pitch: Units_Degrees? = nil
    var _roll: Units_Degrees? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _yaw = source._yaw
      _pitch = source._pitch
      _roll = source._roll
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._yaw)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pitch)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._roll)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._yaw {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pitch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._roll {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Orientation.Error, rhs: Measurements_Orientation.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._yaw != rhs_storage._yaw {return false}
        if _storage._pitch != rhs_storage._pitch {return false}
        if _storage._roll != rhs_storage._roll {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Acceleration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Acceleration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _x: Units_MetersPerSecondSquared? = nil
    var _y: Units_MetersPerSecondSquared? = nil
    var _z: Units_MetersPerSecondSquared? = nil
    var _error: Measurements_Acceleration.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _x = source._x
      _y = source._y
      _z = source._z
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._x)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._y)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._z)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._x {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._y {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._z {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Acceleration, rhs: Measurements_Acceleration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._x != rhs_storage._x {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._z != rhs_storage._z {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Measurements_Acceleration.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Measurements_Acceleration.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  fileprivate class _StorageClass {
    var _x: Units_MetersPerSecond? = nil
    var _y: Units_MetersPerSecond? = nil
    var _z: Units_MetersPerSecond? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _x = source._x
      _y = source._y
      _z = source._z
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._x)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._y)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._z)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._x {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._y {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._z {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Measurements_Acceleration.Error, rhs: Measurements_Acceleration.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._x != rhs_storage._x {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._z != rhs_storage._z {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
