// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: measurements.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 AirMap, Inc.  All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Position models a spatial location.
struct AirMapPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The lat/lng coordinate of the position
  var coordinate: AirMapCoordinate2D {
    get {return _storage._coordinate ?? AirMapCoordinate2D()}
    set {_uniqueStorage()._coordinate = newValue}
  }
  /// Returns true if `coordinate` has been explicitly set.
  var hasCoordinate: Bool {return _storage._coordinate != nil}
  /// Clears the value of `coordinate`. Subsequent reads from it will return its default value.
  mutating func clearCoordinate() {_uniqueStorage()._coordinate = nil}

  /// The altitude component of the position.
  var altitude: AirMapAltitude {
    get {return _storage._altitude ?? AirMapAltitude()}
    set {_uniqueStorage()._altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  var hasAltitude: Bool {return _storage._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  mutating func clearAltitude() {_uniqueStorage()._altitude = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Coordinate2D models a WGS84 latitude and longitude.
struct AirMapCoordinate2D {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The latitude component of this coordinate.
  var latitude: AirMapDegrees {
    get {return _storage._latitude ?? AirMapDegrees()}
    set {_uniqueStorage()._latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return _storage._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {_uniqueStorage()._latitude = nil}

  /// The longitude component of this coordinate.
  var longitude: AirMapDegrees {
    get {return _storage._longitude ?? AirMapDegrees()}
    set {_uniqueStorage()._longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return _storage._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {_uniqueStorage()._longitude = nil}

  /// The error of the coordinate measurement.
  var error: AirMapCoordinate2D.Error {
    get {return _storage._error ?? AirMapCoordinate2D.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in a coordinate measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error estimate on the latitude measurement.
    var latitude: AirMapDegrees {
      get {return _storage._latitude ?? AirMapDegrees()}
      set {_uniqueStorage()._latitude = newValue}
    }
    /// Returns true if `latitude` has been explicitly set.
    var hasLatitude: Bool {return _storage._latitude != nil}
    /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
    mutating func clearLatitude() {_uniqueStorage()._latitude = nil}

    /// The error estimate on the longitude measurement.
    var longitude: AirMapDegrees {
      get {return _storage._longitude ?? AirMapDegrees()}
      set {_uniqueStorage()._longitude = newValue}
    }
    /// Returns true if `longitude` has been explicitly set.
    var hasLongitude: Bool {return _storage._longitude != nil}
    /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
    mutating func clearLongitude() {_uniqueStorage()._longitude = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Altitude models a height measurement from a given datum/reference.
struct AirMapAltitude {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The altitude as measured from the reference.
  var height: AirMapMeters {
    get {return _storage._height ?? AirMapMeters()}
    set {_uniqueStorage()._height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return _storage._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {_uniqueStorage()._height = nil}

  /// The reference from which the altitude was measured.
  var reference: AirMapAltitude.Reference {
    get {return _storage._reference}
    set {_uniqueStorage()._reference = newValue}
  }

  /// The error of the altitude measurement.
  var error: AirMapAltitude.Error {
    get {return _storage._error ?? AirMapAltitude.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Reference enumerates all known reference/datum systems for altitude measurements.
  enum Reference: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// An unknown reference.
    case unknown // = 0

    /// References the hypothetical equipotential gravitational surface.
    case ellipsoid // = 1

    /// References and approximates the mean sea level.
    case geoid // = 2

    /// References the physical surface beneath the measurement.
    case surface // = 3

    /// References an external measurement or estimate.
    case external // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ellipsoid
      case 2: self = .geoid
      case 3: self = .surface
      case 4: self = .external
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ellipsoid: return 1
      case .geoid: return 2
      case .surface: return 3
      case .external: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Error models the inherent error in the altitude measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The altitude error estimate.
    var height: AirMapMeters {
      get {return _storage._height ?? AirMapMeters()}
      set {_uniqueStorage()._height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    var hasHeight: Bool {return _storage._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    mutating func clearHeight() {_uniqueStorage()._height = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension AirMapAltitude.Reference: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AirMapAltitude.Reference] = [
    .unknown,
    .ellipsoid,
    .geoid,
    .surface,
    .external,
  ]
}

#endif  // swift(>=4.2)

/// Course models a course measurement.
struct AirMapCourse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The angle of the course relative to true north.
  var angle: AirMapDegrees {
    get {return _storage._angle ?? AirMapDegrees()}
    set {_uniqueStorage()._angle = newValue}
  }
  /// Returns true if `angle` has been explicitly set.
  var hasAngle: Bool {return _storage._angle != nil}
  /// Clears the value of `angle`. Subsequent reads from it will return its default value.
  mutating func clearAngle() {_uniqueStorage()._angle = nil}

  /// The error of the course measurement.
  var error: AirMapCourse.Error {
    get {return _storage._error ?? AirMapCourse.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in the velocity measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error in course.
    var degrees: AirMapDegrees {
      get {return _storage._degrees ?? AirMapDegrees()}
      set {_uniqueStorage()._degrees = newValue}
    }
    /// Returns true if `degrees` has been explicitly set.
    var hasDegrees: Bool {return _storage._degrees != nil}
    /// Clears the value of `degrees`. Subsequent reads from it will return its default value.
    mutating func clearDegrees() {_uniqueStorage()._degrees = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Velocity models a velocity as XYZ vectors in the NED (north-east-down) coordinate space.
struct AirMapVelocity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The velocity along the X axis.
  var x: AirMapMetersPerSecond {
    get {return _storage._x ?? AirMapMetersPerSecond()}
    set {_uniqueStorage()._x = newValue}
  }
  /// Returns true if `x` has been explicitly set.
  var hasX: Bool {return _storage._x != nil}
  /// Clears the value of `x`. Subsequent reads from it will return its default value.
  mutating func clearX() {_uniqueStorage()._x = nil}

  /// The velocity along the Y axis.
  var y: AirMapMetersPerSecond {
    get {return _storage._y ?? AirMapMetersPerSecond()}
    set {_uniqueStorage()._y = newValue}
  }
  /// Returns true if `y` has been explicitly set.
  var hasY: Bool {return _storage._y != nil}
  /// Clears the value of `y`. Subsequent reads from it will return its default value.
  mutating func clearY() {_uniqueStorage()._y = nil}

  /// The velocity along the Z axis. 
  var z: AirMapMetersPerSecond {
    get {return _storage._z ?? AirMapMetersPerSecond()}
    set {_uniqueStorage()._z = newValue}
  }
  /// Returns true if `z` has been explicitly set.
  var hasZ: Bool {return _storage._z != nil}
  /// Clears the value of `z`. Subsequent reads from it will return its default value.
  mutating func clearZ() {_uniqueStorage()._z = nil}

  /// The error of the velocity measurement.
  var error: AirMapVelocity.Error {
    get {return _storage._error ?? AirMapVelocity.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in the velocity measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error along the X axis.
    var x: AirMapMetersPerSecond {
      get {return _storage._x ?? AirMapMetersPerSecond()}
      set {_uniqueStorage()._x = newValue}
    }
    /// Returns true if `x` has been explicitly set.
    var hasX: Bool {return _storage._x != nil}
    /// Clears the value of `x`. Subsequent reads from it will return its default value.
    mutating func clearX() {_uniqueStorage()._x = nil}

    /// The error along the Y axis.
    var y: AirMapMetersPerSecond {
      get {return _storage._y ?? AirMapMetersPerSecond()}
      set {_uniqueStorage()._y = newValue}
    }
    /// Returns true if `y` has been explicitly set.
    var hasY: Bool {return _storage._y != nil}
    /// Clears the value of `y`. Subsequent reads from it will return its default value.
    mutating func clearY() {_uniqueStorage()._y = nil}

    /// The error along the Z axis.
    var z: AirMapMetersPerSecond {
      get {return _storage._z ?? AirMapMetersPerSecond()}
      set {_uniqueStorage()._z = newValue}
    }
    /// Returns true if `z` has been explicitly set.
    var hasZ: Bool {return _storage._z != nil}
    /// Clears the value of `z`. Subsequent reads from it will return its default value.
    mutating func clearZ() {_uniqueStorage()._z = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Orientation models an attitude or positional orientation measurement.
struct AirMapOrientation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The angular rotation of the vehicle along its vertical axis relative to True North.
  var yaw: AirMapDegrees {
    get {return _storage._yaw ?? AirMapDegrees()}
    set {_uniqueStorage()._yaw = newValue}
  }
  /// Returns true if `yaw` has been explicitly set.
  var hasYaw: Bool {return _storage._yaw != nil}
  /// Clears the value of `yaw`. Subsequent reads from it will return its default value.
  mutating func clearYaw() {_uniqueStorage()._yaw = nil}

  /// The angular rotation of the vehicle along its lateral axis.
  var pitch: AirMapDegrees {
    get {return _storage._pitch ?? AirMapDegrees()}
    set {_uniqueStorage()._pitch = newValue}
  }
  /// Returns true if `pitch` has been explicitly set.
  var hasPitch: Bool {return _storage._pitch != nil}
  /// Clears the value of `pitch`. Subsequent reads from it will return its default value.
  mutating func clearPitch() {_uniqueStorage()._pitch = nil}

  /// The angular rotation of the vehicle along its longitudinal axis.
  var roll: AirMapDegrees {
    get {return _storage._roll ?? AirMapDegrees()}
    set {_uniqueStorage()._roll = newValue}
  }
  /// Returns true if `roll` has been explicitly set.
  var hasRoll: Bool {return _storage._roll != nil}
  /// Clears the value of `roll`. Subsequent reads from it will return its default value.
  mutating func clearRoll() {_uniqueStorage()._roll = nil}

  /// The error of the orientation measurements.
  var error: AirMapOrientation.Error {
    get {return _storage._error ?? AirMapOrientation.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in the orientation measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error in angular rotation of the vehicle along its vertical axis relative to True North.
    var yaw: AirMapDegrees {
      get {return _storage._yaw ?? AirMapDegrees()}
      set {_uniqueStorage()._yaw = newValue}
    }
    /// Returns true if `yaw` has been explicitly set.
    var hasYaw: Bool {return _storage._yaw != nil}
    /// Clears the value of `yaw`. Subsequent reads from it will return its default value.
    mutating func clearYaw() {_uniqueStorage()._yaw = nil}

    /// The error in angular rotation of the vehicle along its lateral axis.
    var pitch: AirMapDegrees {
      get {return _storage._pitch ?? AirMapDegrees()}
      set {_uniqueStorage()._pitch = newValue}
    }
    /// Returns true if `pitch` has been explicitly set.
    var hasPitch: Bool {return _storage._pitch != nil}
    /// Clears the value of `pitch`. Subsequent reads from it will return its default value.
    mutating func clearPitch() {_uniqueStorage()._pitch = nil}

    /// The error in angular rotation of the vehicle along its longitudinal axis.
    var roll: AirMapDegrees {
      get {return _storage._roll ?? AirMapDegrees()}
      set {_uniqueStorage()._roll = newValue}
    }
    /// Returns true if `roll` has been explicitly set.
    var hasRoll: Bool {return _storage._roll != nil}
    /// Clears the value of `roll`. Subsequent reads from it will return its default value.
    mutating func clearRoll() {_uniqueStorage()._roll = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Pressure models an atmospheric pressure measurement.
struct AirMapPressure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The pressure in Pa units.
  var units: AirMapPascal {
    get {return _storage._units ?? AirMapPascal()}
    set {_uniqueStorage()._units = newValue}
  }
  /// Returns true if `units` has been explicitly set.
  var hasUnits: Bool {return _storage._units != nil}
  /// Clears the value of `units`. Subsequent reads from it will return its default value.
  mutating func clearUnits() {_uniqueStorage()._units = nil}

  /// The error in the pressure measurement.
  var error: AirMapPressure.Error {
    get {return _storage._error ?? AirMapPressure.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in an atmospheric pressure measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error in the pressure value.
    var pressure: AirMapPascal {
      get {return _storage._pressure ?? AirMapPascal()}
      set {_uniqueStorage()._pressure = newValue}
    }
    /// Returns true if `pressure` has been explicitly set.
    var hasPressure: Bool {return _storage._pressure != nil}
    /// Clears the value of `pressure`. Subsequent reads from it will return its default value.
    mutating func clearPressure() {_uniqueStorage()._pressure = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Temperature models an atmospheric temperature measurement.
struct AirMapTemperature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The temperature in degrees Celsius.
  var degrees: AirMapCelsius {
    get {return _storage._degrees ?? AirMapCelsius()}
    set {_uniqueStorage()._degrees = newValue}
  }
  /// Returns true if `degrees` has been explicitly set.
  var hasDegrees: Bool {return _storage._degrees != nil}
  /// Clears the value of `degrees`. Subsequent reads from it will return its default value.
  mutating func clearDegrees() {_uniqueStorage()._degrees = nil}

  /// The error in the temperature measurement.
  var error: AirMapTemperature.Error {
    get {return _storage._error ?? AirMapTemperature.Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error models the inherent error in a temperature measurement.
  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error in the temperature value.
    var degrees: AirMapCelsius {
      get {return _storage._degrees ?? AirMapCelsius()}
      set {_uniqueStorage()._degrees = newValue}
    }
    /// Returns true if `degrees` has been explicitly set.
    var hasDegrees: Bool {return _storage._degrees != nil}
    /// Clears the value of `degrees`. Subsequent reads from it will return its default value.
    mutating func clearDegrees() {_uniqueStorage()._degrees = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "airmap"

extension AirMapPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coordinate"),
    2: .same(proto: "altitude"),
  ]

  fileprivate class _StorageClass {
    var _coordinate: AirMapCoordinate2D? = nil
    var _altitude: AirMapAltitude? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _coordinate = source._coordinate
      _altitude = source._altitude
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._coordinate)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._altitude)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._coordinate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._altitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapPosition, rhs: AirMapPosition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coordinate != rhs_storage._coordinate {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapCoordinate2D: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Coordinate2D"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _latitude: AirMapDegrees? = nil
    var _longitude: AirMapDegrees? = nil
    var _error: AirMapCoordinate2D.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _latitude = source._latitude
      _longitude = source._longitude
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._latitude)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._longitude)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._latitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._longitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapCoordinate2D, rhs: AirMapCoordinate2D) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapCoordinate2D.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AirMapCoordinate2D.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  fileprivate class _StorageClass {
    var _latitude: AirMapDegrees? = nil
    var _longitude: AirMapDegrees? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _latitude = source._latitude
      _longitude = source._longitude
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._latitude)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._longitude)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._latitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._longitude {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapCoordinate2D.Error, rhs: AirMapCoordinate2D.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapAltitude: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Altitude"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "reference"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _height: AirMapMeters? = nil
    var _reference: AirMapAltitude.Reference = .unknown
    var _error: AirMapAltitude.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _reference = source._reference
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._height)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._reference)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._height {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._reference != .unknown {
        try visitor.visitSingularEnumField(value: _storage._reference, fieldNumber: 2)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapAltitude, rhs: AirMapAltitude) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._reference != rhs_storage._reference {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapAltitude.Reference: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ELLIPSOID"),
    2: .same(proto: "GEOID"),
    3: .same(proto: "SURFACE"),
    4: .same(proto: "EXTERNAL"),
  ]
}

extension AirMapAltitude.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AirMapAltitude.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  fileprivate class _StorageClass {
    var _height: AirMapMeters? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._height)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._height {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapAltitude.Error, rhs: AirMapAltitude.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapCourse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Course"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "angle"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _angle: AirMapDegrees? = nil
    var _error: AirMapCourse.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _angle = source._angle
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._angle)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._angle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapCourse, rhs: AirMapCourse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._angle != rhs_storage._angle {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapCourse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AirMapCourse.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "degrees"),
  ]

  fileprivate class _StorageClass {
    var _degrees: AirMapDegrees? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _degrees = source._degrees
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._degrees)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._degrees {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapCourse.Error, rhs: AirMapCourse.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._degrees != rhs_storage._degrees {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapVelocity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Velocity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _x: AirMapMetersPerSecond? = nil
    var _y: AirMapMetersPerSecond? = nil
    var _z: AirMapMetersPerSecond? = nil
    var _error: AirMapVelocity.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _x = source._x
      _y = source._y
      _z = source._z
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._x)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._y)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._z)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._x {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._y {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._z {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapVelocity, rhs: AirMapVelocity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._x != rhs_storage._x {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._z != rhs_storage._z {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapVelocity.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AirMapVelocity.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  fileprivate class _StorageClass {
    var _x: AirMapMetersPerSecond? = nil
    var _y: AirMapMetersPerSecond? = nil
    var _z: AirMapMetersPerSecond? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _x = source._x
      _y = source._y
      _z = source._z
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._x)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._y)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._z)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._x {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._y {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._z {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapVelocity.Error, rhs: AirMapVelocity.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._x != rhs_storage._x {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._z != rhs_storage._z {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapOrientation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Orientation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "yaw"),
    2: .same(proto: "pitch"),
    3: .same(proto: "roll"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _yaw: AirMapDegrees? = nil
    var _pitch: AirMapDegrees? = nil
    var _roll: AirMapDegrees? = nil
    var _error: AirMapOrientation.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _yaw = source._yaw
      _pitch = source._pitch
      _roll = source._roll
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._yaw)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pitch)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._roll)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._yaw {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pitch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._roll {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapOrientation, rhs: AirMapOrientation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._yaw != rhs_storage._yaw {return false}
        if _storage._pitch != rhs_storage._pitch {return false}
        if _storage._roll != rhs_storage._roll {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapOrientation.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AirMapOrientation.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "yaw"),
    2: .same(proto: "pitch"),
    3: .same(proto: "roll"),
  ]

  fileprivate class _StorageClass {
    var _yaw: AirMapDegrees? = nil
    var _pitch: AirMapDegrees? = nil
    var _roll: AirMapDegrees? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _yaw = source._yaw
      _pitch = source._pitch
      _roll = source._roll
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._yaw)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pitch)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._roll)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._yaw {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pitch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._roll {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapOrientation.Error, rhs: AirMapOrientation.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._yaw != rhs_storage._yaw {return false}
        if _storage._pitch != rhs_storage._pitch {return false}
        if _storage._roll != rhs_storage._roll {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapPressure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pressure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "units"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _units: AirMapPascal? = nil
    var _error: AirMapPressure.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _units = source._units
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._units)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._units {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapPressure, rhs: AirMapPressure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._units != rhs_storage._units {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapPressure.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AirMapPressure.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressure"),
  ]

  fileprivate class _StorageClass {
    var _pressure: AirMapPascal? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pressure = source._pressure
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._pressure)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._pressure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapPressure.Error, rhs: AirMapPressure.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pressure != rhs_storage._pressure {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapTemperature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Temperature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "degrees"),
    1001: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _degrees: AirMapCelsius? = nil
    var _error: AirMapTemperature.Error? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _degrees = source._degrees
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._degrees)
        case 1001: try decoder.decodeSingularMessageField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._degrees {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapTemperature, rhs: AirMapTemperature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._degrees != rhs_storage._degrees {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirMapTemperature.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AirMapTemperature.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "degrees"),
  ]

  fileprivate class _StorageClass {
    var _degrees: AirMapCelsius? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _degrees = source._degrees
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._degrees)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._degrees {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AirMapTemperature.Error, rhs: AirMapTemperature.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._degrees != rhs_storage._degrees {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
