// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tracking/sensors.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018-2019 AirMap, Inc.  All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Sensor models the method used to observe a track.
struct Tracking_Sensor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// details provides specific information for a given sensor.
  var details: OneOf_Details? {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  /// Marks multiple sensors fused together.
  var fused: Tracking_Sensor.Fused {
    get {
      if case .fused(let v)? = _storage._details {return v}
      return Tracking_Sensor.Fused()
    }
    set {_uniqueStorage()._details = .fused(newValue)}
  }

  /// Marks a primary radar sensor.
  var primaryRadar: Tracking_Sensor.PrimaryRadar {
    get {
      if case .primaryRadar(let v)? = _storage._details {return v}
      return Tracking_Sensor.PrimaryRadar()
    }
    set {_uniqueStorage()._details = .primaryRadar(newValue)}
  }

  /// Marks a secondary radar sensor.
  var secondaryRadar: Tracking_Sensor.SecondaryRadar {
    get {
      if case .secondaryRadar(let v)? = _storage._details {return v}
      return Tracking_Sensor.SecondaryRadar()
    }
    set {_uniqueStorage()._details = .secondaryRadar(newValue)}
  }

  /// Marks an ADS-B sensor.
  var adsb: Tracking_Sensor.Adsb {
    get {
      if case .adsb(let v)? = _storage._details {return v}
      return Tracking_Sensor.Adsb()
    }
    set {_uniqueStorage()._details = .adsb(newValue)}
  }

  /// Marks a satellite-based position sensor.
  var gnss: Tracking_Sensor.Gnss {
    get {
      if case .gnss(let v)? = _storage._details {return v}
      return Tracking_Sensor.Gnss()
    }
    set {_uniqueStorage()._details = .gnss(newValue)}
  }

  /// Marks a Radio Frequency (RF) sensor.
  var radioFrequency: Tracking_Sensor.RadioFrequency {
    get {
      if case .radioFrequency(let v)? = _storage._details {return v}
      return Tracking_Sensor.RadioFrequency()
    }
    set {_uniqueStorage()._details = .radioFrequency(newValue)}
  }

  /// Marks an Electro-Optical sensor.
  var electroOptical: Tracking_Sensor.ElectroOptical {
    get {
      if case .electroOptical(let v)? = _storage._details {return v}
      return Tracking_Sensor.ElectroOptical()
    }
    set {_uniqueStorage()._details = .electroOptical(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// details provides specific information for a given sensor.
  enum OneOf_Details: Equatable {
    /// Marks multiple sensors fused together.
    case fused(Tracking_Sensor.Fused)
    /// Marks a primary radar sensor.
    case primaryRadar(Tracking_Sensor.PrimaryRadar)
    /// Marks a secondary radar sensor.
    case secondaryRadar(Tracking_Sensor.SecondaryRadar)
    /// Marks an ADS-B sensor.
    case adsb(Tracking_Sensor.Adsb)
    /// Marks a satellite-based position sensor.
    case gnss(Tracking_Sensor.Gnss)
    /// Marks a Radio Frequency (RF) sensor.
    case radioFrequency(Tracking_Sensor.RadioFrequency)
    /// Marks an Electro-Optical sensor.
    case electroOptical(Tracking_Sensor.ElectroOptical)

  #if !swift(>=4.1)
    static func ==(lhs: Tracking_Sensor.OneOf_Details, rhs: Tracking_Sensor.OneOf_Details) -> Bool {
      switch (lhs, rhs) {
      case (.fused(let l), .fused(let r)): return l == r
      case (.primaryRadar(let l), .primaryRadar(let r)): return l == r
      case (.secondaryRadar(let l), .secondaryRadar(let r)): return l == r
      case (.adsb(let l), .adsb(let r)): return l == r
      case (.gnss(let l), .gnss(let r)): return l == r
      case (.radioFrequency(let l), .radioFrequency(let r)): return l == r
      case (.electroOptical(let l), .electroOptical(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Fused models multiple fused data sensors.
  struct Fused {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sensors: [Tracking_Sensor] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// PrimaryRadar models a primary radar sensor.
  struct PrimaryRadar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// SecondaryRadar models a secondary radar sensor.
  struct SecondaryRadar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Adsb models an ADS-B sensor.
  struct Adsb {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// RadioFrequency models a Radio Frequency (RF) sensor.
  struct RadioFrequency {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Gnns a satellite-based position sensor.
  struct Gnss {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// ElectroOptical models an Electro-Optical sensor.
  struct ElectroOptical {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tracking"

extension Tracking_Sensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fused"),
    2: .standard(proto: "primary_radar"),
    3: .standard(proto: "secondary_radar"),
    4: .same(proto: "adsb"),
    5: .same(proto: "gnss"),
    6: .standard(proto: "radio_frequency"),
    7: .standard(proto: "electro_optical"),
  ]

  fileprivate class _StorageClass {
    var _details: Tracking_Sensor.OneOf_Details?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _details = source._details
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Tracking_Sensor.Fused?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .fused(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .fused(v)}
        case 2:
          var v: Tracking_Sensor.PrimaryRadar?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .primaryRadar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .primaryRadar(v)}
        case 3:
          var v: Tracking_Sensor.SecondaryRadar?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .secondaryRadar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .secondaryRadar(v)}
        case 4:
          var v: Tracking_Sensor.Adsb?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .adsb(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .adsb(v)}
        case 5:
          var v: Tracking_Sensor.Gnss?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .gnss(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .gnss(v)}
        case 6:
          var v: Tracking_Sensor.RadioFrequency?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .radioFrequency(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .radioFrequency(v)}
        case 7:
          var v: Tracking_Sensor.ElectroOptical?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .electroOptical(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .electroOptical(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._details {
      case .fused(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .primaryRadar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .secondaryRadar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .adsb(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .gnss(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .radioFrequency(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .electroOptical(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Sensor, rhs: Tracking_Sensor) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._details != rhs_storage._details {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.Fused: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".Fused"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.sensors)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sensors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sensors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Sensor.Fused, rhs: Tracking_Sensor.Fused) -> Bool {
    if lhs.sensors != rhs.sensors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.PrimaryRadar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".PrimaryRadar"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Sensor.PrimaryRadar, rhs: Tracking_Sensor.PrimaryRadar) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.SecondaryRadar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".SecondaryRadar"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Sensor.SecondaryRadar, rhs: Tracking_Sensor.SecondaryRadar) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.Adsb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".Adsb"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Sensor.Adsb, rhs: Tracking_Sensor.Adsb) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.RadioFrequency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".RadioFrequency"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Sensor.RadioFrequency, rhs: Tracking_Sensor.RadioFrequency) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.Gnss: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".Gnss"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Sensor.Gnss, rhs: Tracking_Sensor.Gnss) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.ElectroOptical: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".ElectroOptical"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Sensor.ElectroOptical, rhs: Tracking_Sensor.ElectroOptical) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
