// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tracking/track.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018-2019 AirMap, Inc.  All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Track models a single track observation.
struct Tracking_Track {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time the track was observed.
  var observed: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._observed ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._observed = newValue}
  }
  /// Returns true if `observed` has been explicitly set.
  var hasObserved: Bool {return _storage._observed != nil}
  /// Clears the value of `observed`. Subsequent reads from it will return its default value.
  mutating func clearObserved() {_uniqueStorage()._observed = nil}

  /// Position of the vehicle.
  var position: Measurements_Position {
    get {return _storage._position ?? Measurements_Position()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return _storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {_uniqueStorage()._position = nil}

  /// Velocity of the vehicle.
  var velocity: Measurements_Velocity {
    get {return _storage._velocity ?? Measurements_Velocity()}
    set {_uniqueStorage()._velocity = newValue}
  }
  /// Returns true if `velocity` has been explicitly set.
  var hasVelocity: Bool {return _storage._velocity != nil}
  /// Clears the value of `velocity`. Subsequent reads from it will return its default value.
  mutating func clearVelocity() {_uniqueStorage()._velocity = nil}

  /// Orientation of the vehicle.
  var orientation: Measurements_Orientation {
    get {return _storage._orientation ?? Measurements_Orientation()}
    set {_uniqueStorage()._orientation = newValue}
  }
  /// Returns true if `orientation` has been explicitly set.
  var hasOrientation: Bool {return _storage._orientation != nil}
  /// Clears the value of `orientation`. Subsequent reads from it will return its default value.
  mutating func clearOrientation() {_uniqueStorage()._orientation = nil}

  /// Emitter of the track.
  var emitter: Tracking_Emitter {
    get {return _storage._emitter}
    set {_uniqueStorage()._emitter = newValue}
  }

  /// Describes the sensor from which the track originated.
  var sensor: Tracking_Sensor {
    get {return _storage._sensor ?? Tracking_Sensor()}
    set {_uniqueStorage()._sensor = newValue}
  }
  /// Returns true if `sensor` has been explicitly set.
  var hasSensor: Bool {return _storage._sensor != nil}
  /// Clears the value of `sensor`. Subsequent reads from it will return its default value.
  mutating func clearSensor() {_uniqueStorage()._sensor = nil}

  /// All known identities for the track.
  var identities: [Tracking_Identity] {
    get {return _storage._identities}
    set {_uniqueStorage()._identities = newValue}
  }

  /// Status flags for the track.
  var flags: Tracking_Track.Flags {
    get {return _storage._flags ?? Tracking_Track.Flags()}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {_uniqueStorage()._flags = nil}

  /// Vendor-specific details.
  var details: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Flags {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This track has been synthesized via projection.
    var projected: Bool = false

    /// A more recent observation exists from another provider.
    var shadowed: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Batch models a batch of tracks.
  struct Batch {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A batch of tracks.
    var tracks: [Tracking_Track] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tracking"

extension Tracking_Track: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Track"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "observed"),
    2: .same(proto: "position"),
    3: .same(proto: "velocity"),
    4: .same(proto: "orientation"),
    5: .same(proto: "emitter"),
    6: .same(proto: "sensor"),
    7: .same(proto: "identities"),
    8: .same(proto: "flags"),
    1024: .same(proto: "details"),
  ]

  fileprivate class _StorageClass {
    var _observed: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _position: Measurements_Position? = nil
    var _velocity: Measurements_Velocity? = nil
    var _orientation: Measurements_Orientation? = nil
    var _emitter: Tracking_Emitter = .unknown
    var _sensor: Tracking_Sensor? = nil
    var _identities: [Tracking_Identity] = []
    var _flags: Tracking_Track.Flags? = nil
    var _details: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _observed = source._observed
      _position = source._position
      _velocity = source._velocity
      _orientation = source._orientation
      _emitter = source._emitter
      _sensor = source._sensor
      _identities = source._identities
      _flags = source._flags
      _details = source._details
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._observed)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._position)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._velocity)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._orientation)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._emitter)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._sensor)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._identities)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._flags)
        case 1024: try decoder.decodeRepeatedMessageField(value: &_storage._details)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._observed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._velocity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._orientation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._emitter != .unknown {
        try visitor.visitSingularEnumField(value: _storage._emitter, fieldNumber: 5)
      }
      if let v = _storage._sensor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._identities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identities, fieldNumber: 7)
      }
      if let v = _storage._flags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._details.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._details, fieldNumber: 1024)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Track, rhs: Tracking_Track) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._observed != rhs_storage._observed {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._velocity != rhs_storage._velocity {return false}
        if _storage._orientation != rhs_storage._orientation {return false}
        if _storage._emitter != rhs_storage._emitter {return false}
        if _storage._sensor != rhs_storage._sensor {return false}
        if _storage._identities != rhs_storage._identities {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._details != rhs_storage._details {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Track.Flags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Track.protoMessageName + ".Flags"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "projected"),
    2: .same(proto: "shadowed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.projected)
      case 2: try decoder.decodeSingularBoolField(value: &self.shadowed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.projected != false {
      try visitor.visitSingularBoolField(value: self.projected, fieldNumber: 1)
    }
    if self.shadowed != false {
      try visitor.visitSingularBoolField(value: self.shadowed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Track.Flags, rhs: Tracking_Track.Flags) -> Bool {
    if lhs.projected != rhs.projected {return false}
    if lhs.shadowed != rhs.shadowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Track.Batch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Track.protoMessageName + ".Batch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tracks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.tracks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Track.Batch, rhs: Tracking_Track.Batch) -> Bool {
    if lhs.tracks != rhs.tracks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
