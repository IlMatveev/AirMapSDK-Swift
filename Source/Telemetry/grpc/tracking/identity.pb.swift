// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tracking/identity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018-2019 AirMap, Inc.  All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Identity models a unique tracking identity.
struct Tracking_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// details is a discriminated union of all identity types.
  var details: OneOf_Details? {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  var providerID: Tracking_Identity.ProviderId {
    get {
      if case .providerID(let v)? = _storage._details {return v}
      return Tracking_Identity.ProviderId()
    }
    set {_uniqueStorage()._details = .providerID(newValue)}
  }

  var trackID: Tracking_Identity.TrackId {
    get {
      if case .trackID(let v)? = _storage._details {return v}
      return Tracking_Identity.TrackId()
    }
    set {_uniqueStorage()._details = .trackID(newValue)}
  }

  var callsign: Tracking_Identity.Callsign {
    get {
      if case .callsign(let v)? = _storage._details {return v}
      return Tracking_Identity.Callsign()
    }
    set {_uniqueStorage()._details = .callsign(newValue)}
  }

  var registration: Tracking_Identity.Registration {
    get {
      if case .registration(let v)? = _storage._details {return v}
      return Tracking_Identity.Registration()
    }
    set {_uniqueStorage()._details = .registration(newValue)}
  }

  var operation: Tracking_Identity.Operation {
    get {
      if case .operation(let v)? = _storage._details {return v}
      return Tracking_Identity.Operation()
    }
    set {_uniqueStorage()._details = .operation(newValue)}
  }

  var icao: Tracking_Identity.Icao {
    get {
      if case .icao(let v)? = _storage._details {return v}
      return Tracking_Identity.Icao()
    }
    set {_uniqueStorage()._details = .icao(newValue)}
  }

  var manufacturer: Tracking_Identity.Manufacturer {
    get {
      if case .manufacturer(let v)? = _storage._details {return v}
      return Tracking_Identity.Manufacturer()
    }
    set {_uniqueStorage()._details = .manufacturer(newValue)}
  }

  var network: Tracking_Identity.NetworkInterface {
    get {
      if case .network(let v)? = _storage._details {return v}
      return Tracking_Identity.NetworkInterface()
    }
    set {_uniqueStorage()._details = .network(newValue)}
  }

  var imei: Tracking_Identity.IMEI {
    get {
      if case .imei(let v)? = _storage._details {return v}
      return Tracking_Identity.IMEI()
    }
    set {_uniqueStorage()._details = .imei(newValue)}
  }

  var imsi: Tracking_Identity.IMSI {
    get {
      if case .imsi(let v)? = _storage._details {return v}
      return Tracking_Identity.IMSI()
    }
    set {_uniqueStorage()._details = .imsi(newValue)}
  }

  var tracker: Tracking_Identity.Tracker {
    get {
      if case .tracker(let v)? = _storage._details {return v}
      return Tracking_Identity.Tracker()
    }
    set {_uniqueStorage()._details = .tracker(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// details is a discriminated union of all identity types.
  enum OneOf_Details: Equatable {
    case providerID(Tracking_Identity.ProviderId)
    case trackID(Tracking_Identity.TrackId)
    case callsign(Tracking_Identity.Callsign)
    case registration(Tracking_Identity.Registration)
    case operation(Tracking_Identity.Operation)
    case icao(Tracking_Identity.Icao)
    case manufacturer(Tracking_Identity.Manufacturer)
    case network(Tracking_Identity.NetworkInterface)
    case imei(Tracking_Identity.IMEI)
    case imsi(Tracking_Identity.IMSI)
    case tracker(Tracking_Identity.Tracker)

  #if !swift(>=4.1)
    static func ==(lhs: Tracking_Identity.OneOf_Details, rhs: Tracking_Identity.OneOf_Details) -> Bool {
      switch (lhs, rhs) {
      case (.providerID(let l), .providerID(let r)): return l == r
      case (.trackID(let l), .trackID(let r)): return l == r
      case (.callsign(let l), .callsign(let r)): return l == r
      case (.registration(let l), .registration(let r)): return l == r
      case (.operation(let l), .operation(let r)): return l == r
      case (.icao(let l), .icao(let r)): return l == r
      case (.manufacturer(let l), .manufacturer(let r)): return l == r
      case (.network(let l), .network(let r)): return l == r
      case (.imei(let l), .imei(let r)): return l == r
      case (.imsi(let l), .imsi(let r)): return l == r
      case (.tracker(let l), .tracker(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// ProviderId models the unique identifier of a provider of tracks.
  struct ProviderId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asString: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Track models a unique identifier for a track assembled from multiple different observations.
  struct TrackId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asString: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Callsign models the callsign assigned to a vehicle.
  struct Callsign {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asString: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Registration models the registration of an aircraft.
  struct Registration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asString: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Operation models an operation.
  struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The operation identifier.
    var operationID: Ids_Operation {
      get {return _storage._operationID ?? Ids_Operation()}
      set {_uniqueStorage()._operationID = newValue}
    }
    /// Returns true if `operationID` has been explicitly set.
    var hasOperationID: Bool {return _storage._operationID != nil}
    /// Clears the value of `operationID`. Subsequent reads from it will return its default value.
    mutating func clearOperationID() {_uniqueStorage()._operationID = nil}

    /// The UTM Service Supplier that issued the identifier.
    var serviceProviderID: Ids_USS {
      get {return _storage._serviceProviderID ?? Ids_USS()}
      set {_uniqueStorage()._serviceProviderID = newValue}
    }
    /// Returns true if `serviceProviderID` has been explicitly set.
    var hasServiceProviderID: Bool {return _storage._serviceProviderID != nil}
    /// Clears the value of `serviceProviderID`. Subsequent reads from it will return its default value.
    mutating func clearServiceProviderID() {_uniqueStorage()._serviceProviderID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Icao bundles up information that describes an aircraft in the ICAO context.
  struct Icao {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ICAO-assigned address of an aircraft.
    var address: Tracking_Identity.Icao.Address24 {
      get {return _storage._address ?? Tracking_Identity.Icao.Address24()}
      set {_uniqueStorage()._address = newValue}
    }
    /// Returns true if `address` has been explicitly set.
    var hasAddress: Bool {return _storage._address != nil}
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    mutating func clearAddress() {_uniqueStorage()._address = nil}

    /// The ICAO-assigned type of an aircraft.
    var aircraftType: Tracking_Identity.Icao.AircraftType {
      get {return _storage._aircraftType ?? Tracking_Identity.Icao.AircraftType()}
      set {_uniqueStorage()._aircraftType = newValue}
    }
    /// Returns true if `aircraftType` has been explicitly set.
    var hasAircraftType: Bool {return _storage._aircraftType != nil}
    /// Clears the value of `aircraftType`. Subsequent reads from it will return its default value.
    mutating func clearAircraftType() {_uniqueStorage()._aircraftType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Address24 models the unique address of an aircraft assigned by ICAO.
    struct Address24 {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var asString: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    /// AircraftType models an ICAO-registered aircraft type.
    struct AircraftType {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var asString: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Manufacturer identifies a make, model, and serial number of an aircraft or sensor.
  struct Manufacturer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the manufacturer.
    var make: String = String()

    /// The name of the model.
    var model: String = String()

    /// The serial number.
    var serialNumber: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// NetworkInterface identifies a vehicle by its network interfaces.
  struct NetworkInterface {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The hardware address of the network interface.
    var macAddress: Tracking_Identity.NetworkInterface.MACAddress {
      get {return _storage._macAddress ?? Tracking_Identity.NetworkInterface.MACAddress()}
      set {_uniqueStorage()._macAddress = newValue}
    }
    /// Returns true if `macAddress` has been explicitly set.
    var hasMacAddress: Bool {return _storage._macAddress != nil}
    /// Clears the value of `macAddress`. Subsequent reads from it will return its default value.
    mutating func clearMacAddress() {_uniqueStorage()._macAddress = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// MACAddress models the hardware address of the network interface.
    struct MACAddress {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var asString: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// IMEI models the International Mobile Equipment Identity.
  struct IMEI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asString: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// IMSI models the International Mobile Subscriber Identity.
  struct IMSI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asString: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Tracker models a tracker.
  struct Tracker {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The tracker identifier.
    var trackerID: Ids_Tracker {
      get {return _storage._trackerID ?? Ids_Tracker()}
      set {_uniqueStorage()._trackerID = newValue}
    }
    /// Returns true if `trackerID` has been explicitly set.
    var hasTrackerID: Bool {return _storage._trackerID != nil}
    /// Clears the value of `trackerID`. Subsequent reads from it will return its default value.
    mutating func clearTrackerID() {_uniqueStorage()._trackerID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tracking"

extension Tracking_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Identity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_id"),
    2: .standard(proto: "track_id"),
    3: .same(proto: "callsign"),
    4: .same(proto: "registration"),
    5: .same(proto: "operation"),
    6: .same(proto: "icao"),
    7: .same(proto: "manufacturer"),
    8: .same(proto: "network"),
    9: .same(proto: "imei"),
    10: .same(proto: "imsi"),
    11: .same(proto: "tracker"),
  ]

  fileprivate class _StorageClass {
    var _details: Tracking_Identity.OneOf_Details?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _details = source._details
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Tracking_Identity.ProviderId?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .providerID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .providerID(v)}
        case 2:
          var v: Tracking_Identity.TrackId?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .trackID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .trackID(v)}
        case 3:
          var v: Tracking_Identity.Callsign?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .callsign(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .callsign(v)}
        case 4:
          var v: Tracking_Identity.Registration?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .registration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .registration(v)}
        case 5:
          var v: Tracking_Identity.Operation?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .operation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .operation(v)}
        case 6:
          var v: Tracking_Identity.Icao?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .icao(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .icao(v)}
        case 7:
          var v: Tracking_Identity.Manufacturer?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .manufacturer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .manufacturer(v)}
        case 8:
          var v: Tracking_Identity.NetworkInterface?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .network(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .network(v)}
        case 9:
          var v: Tracking_Identity.IMEI?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .imei(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .imei(v)}
        case 10:
          var v: Tracking_Identity.IMSI?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .imsi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .imsi(v)}
        case 11:
          var v: Tracking_Identity.Tracker?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .tracker(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .tracker(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._details {
      case .providerID(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .trackID(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .callsign(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .registration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .operation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .icao(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .manufacturer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .network(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .imei(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .imsi(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .tracker(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity, rhs: Tracking_Identity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._details != rhs_storage._details {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.ProviderId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".ProviderId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.ProviderId, rhs: Tracking_Identity.ProviderId) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.TrackId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".TrackId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.TrackId, rhs: Tracking_Identity.TrackId) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Callsign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Callsign"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.Callsign, rhs: Tracking_Identity.Callsign) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Registration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Registration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.Registration, rhs: Tracking_Identity.Registration) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_id"),
    2: .standard(proto: "service_provider_id"),
  ]

  fileprivate class _StorageClass {
    var _operationID: Ids_Operation? = nil
    var _serviceProviderID: Ids_USS? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operationID = source._operationID
      _serviceProviderID = source._serviceProviderID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._operationID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._serviceProviderID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._operationID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._serviceProviderID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.Operation, rhs: Tracking_Identity.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operationID != rhs_storage._operationID {return false}
        if _storage._serviceProviderID != rhs_storage._serviceProviderID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Icao: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Icao"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "aircraft_type"),
  ]

  fileprivate class _StorageClass {
    var _address: Tracking_Identity.Icao.Address24? = nil
    var _aircraftType: Tracking_Identity.Icao.AircraftType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _aircraftType = source._aircraftType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._aircraftType)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._aircraftType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.Icao, rhs: Tracking_Identity.Icao) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._aircraftType != rhs_storage._aircraftType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Icao.Address24: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.Icao.protoMessageName + ".Address24"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.Icao.Address24, rhs: Tracking_Identity.Icao.Address24) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Icao.AircraftType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.Icao.protoMessageName + ".AircraftType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.Icao.AircraftType, rhs: Tracking_Identity.Icao.AircraftType) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Manufacturer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Manufacturer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "make"),
    2: .same(proto: "model"),
    3: .standard(proto: "serial_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.make)
      case 2: try decoder.decodeSingularStringField(value: &self.model)
      case 3: try decoder.decodeSingularStringField(value: &self.serialNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.make.isEmpty {
      try visitor.visitSingularStringField(value: self.make, fieldNumber: 1)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 2)
    }
    if !self.serialNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.serialNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.Manufacturer, rhs: Tracking_Identity.Manufacturer) -> Bool {
    if lhs.make != rhs.make {return false}
    if lhs.model != rhs.model {return false}
    if lhs.serialNumber != rhs.serialNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.NetworkInterface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".NetworkInterface"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mac_address"),
  ]

  fileprivate class _StorageClass {
    var _macAddress: Tracking_Identity.NetworkInterface.MACAddress? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _macAddress = source._macAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._macAddress)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._macAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.NetworkInterface, rhs: Tracking_Identity.NetworkInterface) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._macAddress != rhs_storage._macAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.NetworkInterface.MACAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.NetworkInterface.protoMessageName + ".MACAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.NetworkInterface.MACAddress, rhs: Tracking_Identity.NetworkInterface.MACAddress) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.IMEI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".IMEI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.IMEI, rhs: Tracking_Identity.IMEI) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.IMSI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".IMSI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.IMSI, rhs: Tracking_Identity.IMSI) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Tracker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Tracker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracker_id"),
  ]

  fileprivate class _StorageClass {
    var _trackerID: Ids_Tracker? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _trackerID = source._trackerID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._trackerID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._trackerID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tracking_Identity.Tracker, rhs: Tracking_Identity.Tracker) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._trackerID != rhs_storage._trackerID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
