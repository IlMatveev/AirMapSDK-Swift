// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tracking/sensors.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018-2019 AirMap, Inc.  All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Sensor models the method used to observe a track.
public struct Tracking_Sensor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// details provides specific information for a given sensor.
  public var details: Tracking_Sensor.OneOf_Details? = nil

  /// Marks multiple sensors fused together.
  public var fused: Tracking_Sensor.Fused {
    get {
      if case .fused(let v)? = details {return v}
      return Tracking_Sensor.Fused()
    }
    set {details = .fused(newValue)}
  }

  /// Marks a primary radar sensor.
  public var primaryRadar: Tracking_Sensor.PrimaryRadar {
    get {
      if case .primaryRadar(let v)? = details {return v}
      return Tracking_Sensor.PrimaryRadar()
    }
    set {details = .primaryRadar(newValue)}
  }

  /// Marks a secondary radar sensor.
  public var secondaryRadar: Tracking_Sensor.SecondaryRadar {
    get {
      if case .secondaryRadar(let v)? = details {return v}
      return Tracking_Sensor.SecondaryRadar()
    }
    set {details = .secondaryRadar(newValue)}
  }

  /// Marks an ADS-B sensor.
  public var adsb: Tracking_Sensor.Adsb {
    get {
      if case .adsb(let v)? = details {return v}
      return Tracking_Sensor.Adsb()
    }
    set {details = .adsb(newValue)}
  }

  /// Marks a satellite-based position sensor.
  public var gnss: Tracking_Sensor.Gnss {
    get {
      if case .gnss(let v)? = details {return v}
      return Tracking_Sensor.Gnss()
    }
    set {details = .gnss(newValue)}
  }

  /// Marks a Radio Frequency (RF) sensor.
  public var radioFrequency: Tracking_Sensor.RadioFrequency {
    get {
      if case .radioFrequency(let v)? = details {return v}
      return Tracking_Sensor.RadioFrequency()
    }
    set {details = .radioFrequency(newValue)}
  }

  /// Marks an Electro-Optical sensor.
  public var electroOptical: Tracking_Sensor.ElectroOptical {
    get {
      if case .electroOptical(let v)? = details {return v}
      return Tracking_Sensor.ElectroOptical()
    }
    set {details = .electroOptical(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// details provides specific information for a given sensor.
  public enum OneOf_Details: Equatable {
    /// Marks multiple sensors fused together.
    case fused(Tracking_Sensor.Fused)
    /// Marks a primary radar sensor.
    case primaryRadar(Tracking_Sensor.PrimaryRadar)
    /// Marks a secondary radar sensor.
    case secondaryRadar(Tracking_Sensor.SecondaryRadar)
    /// Marks an ADS-B sensor.
    case adsb(Tracking_Sensor.Adsb)
    /// Marks a satellite-based position sensor.
    case gnss(Tracking_Sensor.Gnss)
    /// Marks a Radio Frequency (RF) sensor.
    case radioFrequency(Tracking_Sensor.RadioFrequency)
    /// Marks an Electro-Optical sensor.
    case electroOptical(Tracking_Sensor.ElectroOptical)

  #if !swift(>=4.1)
    public static func ==(lhs: Tracking_Sensor.OneOf_Details, rhs: Tracking_Sensor.OneOf_Details) -> Bool {
      switch (lhs, rhs) {
      case (.fused(let l), .fused(let r)): return l == r
      case (.primaryRadar(let l), .primaryRadar(let r)): return l == r
      case (.secondaryRadar(let l), .secondaryRadar(let r)): return l == r
      case (.adsb(let l), .adsb(let r)): return l == r
      case (.gnss(let l), .gnss(let r)): return l == r
      case (.radioFrequency(let l), .radioFrequency(let r)): return l == r
      case (.electroOptical(let l), .electroOptical(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Fused models multiple fused data sensors.
  public struct Fused {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sensors: [Tracking_Sensor] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// PrimaryRadar models a primary radar sensor.
  public struct PrimaryRadar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// SecondaryRadar models a secondary radar sensor.
  public struct SecondaryRadar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Adsb models an ADS-B sensor.
  public struct Adsb {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// RadioFrequency models a Radio Frequency (RF) sensor.
  public struct RadioFrequency {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Gnns a satellite-based position sensor.
  public struct Gnss {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// ElectroOptical models an Electro-Optical sensor.
  public struct ElectroOptical {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tracking"

extension Tracking_Sensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sensor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fused"),
    2: .standard(proto: "primary_radar"),
    3: .standard(proto: "secondary_radar"),
    4: .same(proto: "adsb"),
    5: .same(proto: "gnss"),
    6: .standard(proto: "radio_frequency"),
    7: .standard(proto: "electro_optical"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Tracking_Sensor.Fused?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .fused(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .fused(v)}
      case 2:
        var v: Tracking_Sensor.PrimaryRadar?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .primaryRadar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .primaryRadar(v)}
      case 3:
        var v: Tracking_Sensor.SecondaryRadar?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .secondaryRadar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .secondaryRadar(v)}
      case 4:
        var v: Tracking_Sensor.Adsb?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .adsb(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .adsb(v)}
      case 5:
        var v: Tracking_Sensor.Gnss?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .gnss(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .gnss(v)}
      case 6:
        var v: Tracking_Sensor.RadioFrequency?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .radioFrequency(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .radioFrequency(v)}
      case 7:
        var v: Tracking_Sensor.ElectroOptical?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .electroOptical(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .electroOptical(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.details {
    case .fused(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .primaryRadar(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .secondaryRadar(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .adsb(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .gnss(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .radioFrequency(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case .electroOptical(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Sensor, rhs: Tracking_Sensor) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.Fused: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".Fused"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.sensors)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sensors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sensors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Sensor.Fused, rhs: Tracking_Sensor.Fused) -> Bool {
    if lhs.sensors != rhs.sensors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.PrimaryRadar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".PrimaryRadar"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Sensor.PrimaryRadar, rhs: Tracking_Sensor.PrimaryRadar) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.SecondaryRadar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".SecondaryRadar"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Sensor.SecondaryRadar, rhs: Tracking_Sensor.SecondaryRadar) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.Adsb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".Adsb"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Sensor.Adsb, rhs: Tracking_Sensor.Adsb) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.RadioFrequency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".RadioFrequency"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Sensor.RadioFrequency, rhs: Tracking_Sensor.RadioFrequency) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.Gnss: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".Gnss"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Sensor.Gnss, rhs: Tracking_Sensor.Gnss) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Sensor.ElectroOptical: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Sensor.protoMessageName + ".ElectroOptical"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Sensor.ElectroOptical, rhs: Tracking_Sensor.ElectroOptical) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
