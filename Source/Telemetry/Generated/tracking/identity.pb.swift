// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tracking/identity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018-2019 AirMap, Inc.  All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Identity models a unique tracking identity.
public struct Tracking_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// details is a discriminated union of all identity types.
  public var details: Tracking_Identity.OneOf_Details? = nil

  public var providerID: Tracking_Identity.ProviderId {
    get {
      if case .providerID(let v)? = details {return v}
      return Tracking_Identity.ProviderId()
    }
    set {details = .providerID(newValue)}
  }

  public var trackID: Tracking_Identity.TrackId {
    get {
      if case .trackID(let v)? = details {return v}
      return Tracking_Identity.TrackId()
    }
    set {details = .trackID(newValue)}
  }

  public var callsign: Tracking_Identity.Callsign {
    get {
      if case .callsign(let v)? = details {return v}
      return Tracking_Identity.Callsign()
    }
    set {details = .callsign(newValue)}
  }

  public var registration: Tracking_Identity.Registration {
    get {
      if case .registration(let v)? = details {return v}
      return Tracking_Identity.Registration()
    }
    set {details = .registration(newValue)}
  }

  public var operation: Tracking_Identity.Operation {
    get {
      if case .operation(let v)? = details {return v}
      return Tracking_Identity.Operation()
    }
    set {details = .operation(newValue)}
  }

  public var icao: Tracking_Identity.Icao {
    get {
      if case .icao(let v)? = details {return v}
      return Tracking_Identity.Icao()
    }
    set {details = .icao(newValue)}
  }

  public var manufacturer: Tracking_Identity.Manufacturer {
    get {
      if case .manufacturer(let v)? = details {return v}
      return Tracking_Identity.Manufacturer()
    }
    set {details = .manufacturer(newValue)}
  }

  public var network: Tracking_Identity.NetworkInterface {
    get {
      if case .network(let v)? = details {return v}
      return Tracking_Identity.NetworkInterface()
    }
    set {details = .network(newValue)}
  }

  public var imei: Tracking_Identity.IMEI {
    get {
      if case .imei(let v)? = details {return v}
      return Tracking_Identity.IMEI()
    }
    set {details = .imei(newValue)}
  }

  public var imsi: Tracking_Identity.IMSI {
    get {
      if case .imsi(let v)? = details {return v}
      return Tracking_Identity.IMSI()
    }
    set {details = .imsi(newValue)}
  }

  public var tracker: Tracking_Identity.Tracker {
    get {
      if case .tracker(let v)? = details {return v}
      return Tracking_Identity.Tracker()
    }
    set {details = .tracker(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// details is a discriminated union of all identity types.
  public enum OneOf_Details: Equatable {
    case providerID(Tracking_Identity.ProviderId)
    case trackID(Tracking_Identity.TrackId)
    case callsign(Tracking_Identity.Callsign)
    case registration(Tracking_Identity.Registration)
    case operation(Tracking_Identity.Operation)
    case icao(Tracking_Identity.Icao)
    case manufacturer(Tracking_Identity.Manufacturer)
    case network(Tracking_Identity.NetworkInterface)
    case imei(Tracking_Identity.IMEI)
    case imsi(Tracking_Identity.IMSI)
    case tracker(Tracking_Identity.Tracker)

  #if !swift(>=4.1)
    public static func ==(lhs: Tracking_Identity.OneOf_Details, rhs: Tracking_Identity.OneOf_Details) -> Bool {
      switch (lhs, rhs) {
      case (.providerID(let l), .providerID(let r)): return l == r
      case (.trackID(let l), .trackID(let r)): return l == r
      case (.callsign(let l), .callsign(let r)): return l == r
      case (.registration(let l), .registration(let r)): return l == r
      case (.operation(let l), .operation(let r)): return l == r
      case (.icao(let l), .icao(let r)): return l == r
      case (.manufacturer(let l), .manufacturer(let r)): return l == r
      case (.network(let l), .network(let r)): return l == r
      case (.imei(let l), .imei(let r)): return l == r
      case (.imsi(let l), .imsi(let r)): return l == r
      case (.tracker(let l), .tracker(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// ProviderId models the unique identifier of a provider of tracks.
  public struct ProviderId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var asString: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Track models a unique identifier for a track assembled from multiple different observations.
  public struct TrackId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var asString: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Callsign models the callsign assigned to a vehicle.
  public struct Callsign {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var asString: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Registration models the registration of an aircraft.
  public struct Registration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var asString: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Operation models an operation.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The operation identifier.
    public var operationID: Ids_Operation {
      get {return _operationID ?? Ids_Operation()}
      set {_operationID = newValue}
    }
    /// Returns true if `operationID` has been explicitly set.
    public var hasOperationID: Bool {return self._operationID != nil}
    /// Clears the value of `operationID`. Subsequent reads from it will return its default value.
    public mutating func clearOperationID() {self._operationID = nil}

    /// The UTM Service Supplier that issued the identifier.
    public var serviceProviderID: Ids_USS {
      get {return _serviceProviderID ?? Ids_USS()}
      set {_serviceProviderID = newValue}
    }
    /// Returns true if `serviceProviderID` has been explicitly set.
    public var hasServiceProviderID: Bool {return self._serviceProviderID != nil}
    /// Clears the value of `serviceProviderID`. Subsequent reads from it will return its default value.
    public mutating func clearServiceProviderID() {self._serviceProviderID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _operationID: Ids_Operation? = nil
    fileprivate var _serviceProviderID: Ids_USS? = nil
  }

  /// Icao bundles up information that describes an aircraft in the ICAO context.
  public struct Icao {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ICAO-assigned address of an aircraft.
    public var address: Tracking_Identity.Icao.Address24 {
      get {return _address ?? Tracking_Identity.Icao.Address24()}
      set {_address = newValue}
    }
    /// Returns true if `address` has been explicitly set.
    public var hasAddress: Bool {return self._address != nil}
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    public mutating func clearAddress() {self._address = nil}

    /// The ICAO-assigned type of an aircraft.
    public var aircraftType: Tracking_Identity.Icao.AircraftType {
      get {return _aircraftType ?? Tracking_Identity.Icao.AircraftType()}
      set {_aircraftType = newValue}
    }
    /// Returns true if `aircraftType` has been explicitly set.
    public var hasAircraftType: Bool {return self._aircraftType != nil}
    /// Clears the value of `aircraftType`. Subsequent reads from it will return its default value.
    public mutating func clearAircraftType() {self._aircraftType = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Address24 models the unique address of an aircraft assigned by ICAO.
    public struct Address24 {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var asString: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// AircraftType models an ICAO-registered aircraft type.
    public struct AircraftType {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var asString: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _address: Tracking_Identity.Icao.Address24? = nil
    fileprivate var _aircraftType: Tracking_Identity.Icao.AircraftType? = nil
  }

  /// Manufacturer identifies a make, model, and serial number of an aircraft or sensor.
  public struct Manufacturer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the manufacturer.
    public var make: String = String()

    /// The name of the model.
    public var model: String = String()

    /// The serial number.
    public var serialNumber: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// NetworkInterface identifies a vehicle by its network interfaces.
  public struct NetworkInterface {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The hardware address of the network interface.
    public var macAddress: Tracking_Identity.NetworkInterface.MACAddress {
      get {return _macAddress ?? Tracking_Identity.NetworkInterface.MACAddress()}
      set {_macAddress = newValue}
    }
    /// Returns true if `macAddress` has been explicitly set.
    public var hasMacAddress: Bool {return self._macAddress != nil}
    /// Clears the value of `macAddress`. Subsequent reads from it will return its default value.
    public mutating func clearMacAddress() {self._macAddress = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// MACAddress models the hardware address of the network interface.
    public struct MACAddress {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var asString: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _macAddress: Tracking_Identity.NetworkInterface.MACAddress? = nil
  }

  /// IMEI models the International Mobile Equipment Identity.
  public struct IMEI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var asString: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// IMSI models the International Mobile Subscriber Identity.
  public struct IMSI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var asString: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Tracker models a tracker.
  public struct Tracker {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The tracker identifier.
    public var trackerID: Ids_Tracker {
      get {return _trackerID ?? Ids_Tracker()}
      set {_trackerID = newValue}
    }
    /// Returns true if `trackerID` has been explicitly set.
    public var hasTrackerID: Bool {return self._trackerID != nil}
    /// Clears the value of `trackerID`. Subsequent reads from it will return its default value.
    public mutating func clearTrackerID() {self._trackerID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _trackerID: Ids_Tracker? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tracking"

extension Tracking_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Identity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_id"),
    2: .standard(proto: "track_id"),
    3: .same(proto: "callsign"),
    4: .same(proto: "registration"),
    5: .same(proto: "operation"),
    6: .same(proto: "icao"),
    7: .same(proto: "manufacturer"),
    8: .same(proto: "network"),
    9: .same(proto: "imei"),
    10: .same(proto: "imsi"),
    11: .same(proto: "tracker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Tracking_Identity.ProviderId?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .providerID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .providerID(v)}
      case 2:
        var v: Tracking_Identity.TrackId?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .trackID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .trackID(v)}
      case 3:
        var v: Tracking_Identity.Callsign?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .callsign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .callsign(v)}
      case 4:
        var v: Tracking_Identity.Registration?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .registration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .registration(v)}
      case 5:
        var v: Tracking_Identity.Operation?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .operation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .operation(v)}
      case 6:
        var v: Tracking_Identity.Icao?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .icao(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .icao(v)}
      case 7:
        var v: Tracking_Identity.Manufacturer?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .manufacturer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .manufacturer(v)}
      case 8:
        var v: Tracking_Identity.NetworkInterface?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .network(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .network(v)}
      case 9:
        var v: Tracking_Identity.IMEI?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .imei(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .imei(v)}
      case 10:
        var v: Tracking_Identity.IMSI?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .imsi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .imsi(v)}
      case 11:
        var v: Tracking_Identity.Tracker?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .tracker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .tracker(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.details {
    case .providerID(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .trackID(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .callsign(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .registration(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .operation(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .icao(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case .manufacturer(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    case .network(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    case .imei(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    case .imsi(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    case .tracker(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity, rhs: Tracking_Identity) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.ProviderId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".ProviderId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.ProviderId, rhs: Tracking_Identity.ProviderId) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.TrackId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".TrackId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.TrackId, rhs: Tracking_Identity.TrackId) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Callsign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Callsign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.Callsign, rhs: Tracking_Identity.Callsign) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Registration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Registration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.Registration, rhs: Tracking_Identity.Registration) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_id"),
    2: .standard(proto: "service_provider_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._operationID)
      case 2: try decoder.decodeSingularMessageField(value: &self._serviceProviderID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._operationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._serviceProviderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.Operation, rhs: Tracking_Identity.Operation) -> Bool {
    if lhs._operationID != rhs._operationID {return false}
    if lhs._serviceProviderID != rhs._serviceProviderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Icao: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Icao"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "aircraft_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._address)
      case 2: try decoder.decodeSingularMessageField(value: &self._aircraftType)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._aircraftType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.Icao, rhs: Tracking_Identity.Icao) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs._aircraftType != rhs._aircraftType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Icao.Address24: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.Icao.protoMessageName + ".Address24"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.Icao.Address24, rhs: Tracking_Identity.Icao.Address24) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Icao.AircraftType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.Icao.protoMessageName + ".AircraftType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.Icao.AircraftType, rhs: Tracking_Identity.Icao.AircraftType) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Manufacturer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Manufacturer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "make"),
    2: .same(proto: "model"),
    3: .standard(proto: "serial_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.make)
      case 2: try decoder.decodeSingularStringField(value: &self.model)
      case 3: try decoder.decodeSingularStringField(value: &self.serialNumber)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.make.isEmpty {
      try visitor.visitSingularStringField(value: self.make, fieldNumber: 1)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 2)
    }
    if !self.serialNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.serialNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.Manufacturer, rhs: Tracking_Identity.Manufacturer) -> Bool {
    if lhs.make != rhs.make {return false}
    if lhs.model != rhs.model {return false}
    if lhs.serialNumber != rhs.serialNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.NetworkInterface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".NetworkInterface"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mac_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._macAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._macAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.NetworkInterface, rhs: Tracking_Identity.NetworkInterface) -> Bool {
    if lhs._macAddress != rhs._macAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.NetworkInterface.MACAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.NetworkInterface.protoMessageName + ".MACAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.NetworkInterface.MACAddress, rhs: Tracking_Identity.NetworkInterface.MACAddress) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.IMEI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".IMEI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.IMEI, rhs: Tracking_Identity.IMEI) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.IMSI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".IMSI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.asString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asString.isEmpty {
      try visitor.visitSingularStringField(value: self.asString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.IMSI, rhs: Tracking_Identity.IMSI) -> Bool {
    if lhs.asString != rhs.asString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Identity.Tracker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Identity.protoMessageName + ".Tracker"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._trackerID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._trackerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Identity.Tracker, rhs: Tracking_Identity.Tracker) -> Bool {
    if lhs._trackerID != rhs._trackerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
