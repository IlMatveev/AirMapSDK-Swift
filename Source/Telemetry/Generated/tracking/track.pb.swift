// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tracking/track.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018-2019 AirMap, Inc.  All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Track models a single track observation.
public struct Tracking_Track {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time the track was observed.
  public var observed: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _observed ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_observed = newValue}
  }
  /// Returns true if `observed` has been explicitly set.
  public var hasObserved: Bool {return self._observed != nil}
  /// Clears the value of `observed`. Subsequent reads from it will return its default value.
  public mutating func clearObserved() {self._observed = nil}

  /// Position of the vehicle.
  public var position: Measurements_Position {
    get {return _position ?? Measurements_Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  /// Velocity of the vehicle.
  public var velocity: Measurements_Velocity {
    get {return _velocity ?? Measurements_Velocity()}
    set {_velocity = newValue}
  }
  /// Returns true if `velocity` has been explicitly set.
  public var hasVelocity: Bool {return self._velocity != nil}
  /// Clears the value of `velocity`. Subsequent reads from it will return its default value.
  public mutating func clearVelocity() {self._velocity = nil}

  /// Orientation of the vehicle.
  public var orientation: Measurements_Orientation {
    get {return _orientation ?? Measurements_Orientation()}
    set {_orientation = newValue}
  }
  /// Returns true if `orientation` has been explicitly set.
  public var hasOrientation: Bool {return self._orientation != nil}
  /// Clears the value of `orientation`. Subsequent reads from it will return its default value.
  public mutating func clearOrientation() {self._orientation = nil}

  /// Emitter of the track.
  public var emitter: Tracking_Emitter = .unknown

  /// Describes the sensor from which the track originated.
  public var sensor: Tracking_Sensor {
    get {return _sensor ?? Tracking_Sensor()}
    set {_sensor = newValue}
  }
  /// Returns true if `sensor` has been explicitly set.
  public var hasSensor: Bool {return self._sensor != nil}
  /// Clears the value of `sensor`. Subsequent reads from it will return its default value.
  public mutating func clearSensor() {self._sensor = nil}

  /// All known identities for the track.
  public var identities: [Tracking_Identity] = []

  /// Status flags for the track.
  public var flags: Tracking_Track.Flags {
    get {return _flags ?? Tracking_Track.Flags()}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  public var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  public mutating func clearFlags() {self._flags = nil}

  /// Vendor-specific details.
  public var details: [SwiftProtobuf.Google_Protobuf_Any] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Flags {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This track has been synthesized via projection.
    public var projected: Bool = false

    /// A more recent observation exists from another provider.
    public var shadowed: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Batch models a batch of tracks.
  public struct Batch {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A batch of tracks.
    public var tracks: [Tracking_Track] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _observed: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _position: Measurements_Position? = nil
  fileprivate var _velocity: Measurements_Velocity? = nil
  fileprivate var _orientation: Measurements_Orientation? = nil
  fileprivate var _sensor: Tracking_Sensor? = nil
  fileprivate var _flags: Tracking_Track.Flags? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tracking"

extension Tracking_Track: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Track"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "observed"),
    2: .same(proto: "position"),
    3: .same(proto: "velocity"),
    4: .same(proto: "orientation"),
    5: .same(proto: "emitter"),
    6: .same(proto: "sensor"),
    7: .same(proto: "identities"),
    8: .same(proto: "flags"),
    1024: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._observed)
      case 2: try decoder.decodeSingularMessageField(value: &self._position)
      case 3: try decoder.decodeSingularMessageField(value: &self._velocity)
      case 4: try decoder.decodeSingularMessageField(value: &self._orientation)
      case 5: try decoder.decodeSingularEnumField(value: &self.emitter)
      case 6: try decoder.decodeSingularMessageField(value: &self._sensor)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.identities)
      case 8: try decoder.decodeSingularMessageField(value: &self._flags)
      case 1024: try decoder.decodeRepeatedMessageField(value: &self.details)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._observed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._velocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._orientation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.emitter != .unknown {
      try visitor.visitSingularEnumField(value: self.emitter, fieldNumber: 5)
    }
    if let v = self._sensor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.identities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identities, fieldNumber: 7)
    }
    if let v = self._flags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.details.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.details, fieldNumber: 1024)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Track, rhs: Tracking_Track) -> Bool {
    if lhs._observed != rhs._observed {return false}
    if lhs._position != rhs._position {return false}
    if lhs._velocity != rhs._velocity {return false}
    if lhs._orientation != rhs._orientation {return false}
    if lhs.emitter != rhs.emitter {return false}
    if lhs._sensor != rhs._sensor {return false}
    if lhs.identities != rhs.identities {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Track.Flags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Track.protoMessageName + ".Flags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "projected"),
    2: .same(proto: "shadowed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.projected)
      case 2: try decoder.decodeSingularBoolField(value: &self.shadowed)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.projected != false {
      try visitor.visitSingularBoolField(value: self.projected, fieldNumber: 1)
    }
    if self.shadowed != false {
      try visitor.visitSingularBoolField(value: self.shadowed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Track.Flags, rhs: Tracking_Track.Flags) -> Bool {
    if lhs.projected != rhs.projected {return false}
    if lhs.shadowed != rhs.shadowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tracking_Track.Batch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tracking_Track.protoMessageName + ".Batch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tracks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.tracks)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tracking_Track.Batch, rhs: Tracking_Track.Batch) -> Bool {
    if lhs.tracks != rhs.tracks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
